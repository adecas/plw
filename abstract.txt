META PROGRAMMING
================

any type
--------

any, ou utilise any

	ex: any, [any], {a int, b any}
	
les types any ne peuvent etre déclaré qu'en parametre d'une function ou d'une procedure		


macro function / procedure
--------------------------

quand un des parametres est de type any

function toto(a int, b any) int begin
	return a + length(b);
end toto;

lors de la compilation, quand toto est appelé avec une type concret:

	soit la fonction concrete existe.
	
	soit la fonction concrete est créé a partir de la macro
	
		var a := toto(1, 2);
		
		essaie de compiler la fonction toto(int,int) avec le code de la macro
		
		echec si la fonction length(int) n'existe pas
		
note: le retour ne peut etre any que pour une macro

	function add(a any, b any) any begin
		return a + b;
	end add;		
		
exemple
-------

type circle {radius: real};
type rect {width: real, height: real};

function perimeter(c circle) real begin
	return 2 * PI * radius;
end perimeter;

function perimeter(r rect) real begin
	return 2 * (r.width + r.height);
end perimeter;

procedure display_perimeters(shapes [any]) begin
	for shape in shapes loop
		print('Perimeter is: ' || text(perimeter(shape)));
	end loop;
end display_perimeter;


variant
-------

Un variant declare plusieurs types possibles

integer|text|real

example:

	function f(a integer) integer|text begin
		return case a when 0 then 42 else '42' end;
	end f;

	var a := f(random(0, 1));	# a contient deux elements, la valeur de a, et l'index de son type dans le variant
	
	var b := ['42', 42];        # b est de type [integer|text]; 

Quand on appelle une function avec un variant, on verifie qu'il existe une function
pour tous les types de variant.

	print(a);
	
		1 - verifie l'existence d'une function print(integer|text), si oui l'appelle
		2 - verifie l'existance des functions print(integer) et print(text), sinon, erreur de compil
		3 - genere une function de dispatch print(integer|text) qui dirige vers print(integer)
		    ou print(text) suivant l'index du type du variant conservé au runtime
		    
note:

	Pour le step one, s'il existe une fonction print(integer|text|real), on peut l'utiliser
	
kindof permet tester le type d'un variant

	var b := ['42', 42, 42.0, false];					# b est de type [boolean|integer|real|text]

	var c := kindof b[0]							    # on peut faire aussi kindof <variablename>	
				when integer i then 'Hello ' || text(i)	# k est de type integer dans le bloc then
				when text t then 'Hello ' || t
				else 'unknown'							  
			 end;										
			 
kindof existe aussi en statement

	kindof b[0]
	when text t then
		print('Hello ' || t);
	end;
		    

Example global
--------------

Avec l'exemple si dessus on peut faire:

type square {width real};

function perimeter(s square) real begin
	return 4 * s.width;
end perimeter;	
	
var shapes := [] as [circle|rect|square]; # make a liste of shapes

display_perimeters(shapes);


Optimisation Simple
===================

function invert(p {x integer, y integer}) {x integer, y integer} begin
	p.x := -p.x;
	p.y := -p.y;
	return p;
end invert;

var p := {x: 1, y: 2};

p := invert(p);

Avant d'appeler la fonction invert, on peut decrementer le refcount de p

Sauf si l'appel invert est dans un bloc avec exception handling
	et que p n'est pas déclaré dans le scope de ce bloc
	
	var p := {x: 1, y: 2};

	begin
		p := invert(p);
	exception
		when out_of_mem then
			...
	end;

Si p est une expression ...

	l[i] := invert(l[i]);

Il ne faut pas que l'expression contienne une variable qui soit un param ctx

	l[i] := invert(l[i], ctx i);
	
Strategie:

	Lors d'un assignement
	
		Si l'expression de gauche est une ref
	
		Si l'expression de gauche est contenu dans l'expression de droite
		
		Si aucune variable de l'expression de gauche n'est un param ctx dans l'expression de droite

		Appelons root le premier terme de l'expression de gauche
		
		Si il n'y a pas d'exception handling entre le scope ou root est declaré (exclu) et le scope courant		
		
		Lors de l'evaluation de l'expression de gauche a droite
		
			On n'incremente pas la ref finale. Comment ???
			
			Move Opcode ?
		
		
	
	
	
		 
	

































