META PROGRAMMING
================

any type
--------

any, ou utilise any

	ex: any, [any], {a int, b any}
	
les types any ne peuvent etre déclaré qu'en parametre d'une function ou d'une procedure		


macro function / procedure
--------------------------

quand un des parametres est de type any

function toto(a int, b any) int begin
	return a + length(b);
end toto;

lors de la compilation, quand toto est appelé avec une type concret:

	soit la fonction concrete existe.
	
	soit la fonction concrete est créé a partir de la macro
	
		var a := toto(1, 2);
		
		essaie de compiler la fonction toto(int,int) avec le code de la macro
		
		echec si la fonction length(int) n'existe pas
		
note: le retour ne peut etre any que pour une macro

	function add(a any, b any) any begin
		return a + b;
	end add;		
		
exemple
-------

type circle {radius: real};
type rect {width: real, height: real};

function perimeter(c circle) real begin
	return 2 * PI * radius;
end perimeter;

function perimeter(r rect) real begin
	return 2 * (r.width + r.height);
end perimeter;

procedure display_perimeters(shapes [any]) begin
	for shape in shapes loop
		print('Perimeter is: ' || text(perimeter(shape)));
	end loop;
end display_perimeter;


variant
-------

Un variant declare plusieurs types possibles

integer|text|real

example:

	function f(a integer) integer|text begin
		return case a when 0 then 42 else '42' end;
	end f;

	var a := f(random(0, 1));	# a contient deux elements, la valeur de a, et l'index de son type dans le variant
	
	var b := ['42', 42];        # b est de type [integer|text]; 

Quand on appelle une function avec un variant, on verifie qu'il existe une function
pour tous les types de variant.

	print(a);
	
		1 - verifie l'existence d'une function print(integer|text), si oui l'appelle
		2 - verifie l'existance des functions print(integer) et print(text), sinon, erreur de compil
		3 - genere une function de dispatch print(integer|text) qui dirige vers print(integer)
		    ou print(text) suivant l'index du type du variant conservé au runtime
		    
note:

	Pour le step one, s'il existe une fonction print(integer|text|real), on peut l'utiliser
	
kindof permet tester le type d'un variant

	var b := ['42', 42, 42.0, false];					# b est de type [boolean|integer|real|text]

	var c := kindof b[0]							    # on peut faire aussi kindof <variablename>	
				when integer i then 'Hello ' || text(i)	# k est de type integer dans le bloc then
				when text t then 'Hello ' || t
				else 'unknown'							  
			 end;										
			 
kindof existe aussi en statement

	kindof b[0]
	when text t then
		print('Hello ' || t);
	end;
		    

Example global
--------------

Avec l'exemple si dessus on peut faire:

type square {width real};

function perimeter(s square) real begin
	return 4 * s.width;
end perimeter;	
	
var shapes := [] as [circle|rect|square]; # make a liste of shapes

display_perimeters(shapes);


Optimisation Simple
===================

function invert(p {x integer, y integer}) {x integer, y integer} begin
	p.x := -p.x;
	p.y := -p.y;
	return p;
end invert;

var p := {x: 1, y: 2};

p := invert(p);

Avant d'appeler la fonction invert, on peut decrementer le refcount de p

Sauf si l'appel invert est dans un bloc avec exception handling
	et que p n'est pas déclaré dans le scope de ce bloc
	
	var p := {x: 1, y: 2};

	begin
		p := invert(p);
	exception
		when out_of_mem then
			...
	end;

Si p est une expression ...

	l[i] := invert(l[i]);

Il ne faut pas que l'expression contienne une variable qui soit un param ctx

	l[i] := invert(l[i], ctx i);
	
Strategie:

	Lors d'un assignement
	
		Si l'expression de gauche est une ref
	
		Si l'expression de gauche est contenu dans l'expression de droite
		
		Si aucune variable de l'expression de gauche n'est modifiée par l'expression de droite (est un param ctx dans l'expression de droite)

		Appelons root le premier terme de l'expression de gauche
		
		Si il n'y a pas d'exception handling entre le scope ou root est declaré (exclu) et le scope courant		
		
		Avant le call de la fonction, on assigne 0 a l'expression de gauche
		
		
Quick Win Strategie:

	A chaque variable on associe deux listes de location, une confirmed, et une tmp
	
	quand une variable sort du scope, on remplace les push_local des locs des deux listes par un push_local_move
	
	Une assignation de la variable transfert les locs tmp dans confirmes
	
	Un read de la variable remplace les locs tmp par une liste d'un element avec la loc courante
	
	Gestion d'evaluation conditionnelle (if/else, case/when):
	
		Au début:
			* transfert les confirmed et tmp dans une variableLocal before
			
		Avant l'eval conditionelle:
			* vide les confirmed, copie les before.tmp dans tmp
		
		Apres l'eval conditionelle:
			* transfert les confirmed et tmp dans une variable locale condEvalN 

		A la fin:
			* copie les before.confirmed dans confirmed
			* ajoute tous les condEvalN.confirmed sauf si la loc est dans before.tmp
			* Si toues les cas gérés, ajoute les before.tmp dans confirmed si la loc est dans tous les condEvalN.confirmed,
			* Ajoute tous les condEvalN.tmp dans tmp, sauf si la loc est dans before.tmp
			* Ajoute les before.tmp dans tmp, seulement is le tmp de la variable est question est vide
	
	
	
-- cas basique
 1: begin
 2:   var toto := 'hello';			-- [], []
 3:   print(toto);					-- [], [3]
 4:   print(toto);					-- [], [4]
 5:   toto := 'hello';				-- [4], []
 6:   print(toto);					-- [4], [6]
 7: end; 
	
-- cas if read
 1: begin
 2:   var toto := 'hello';			-- [], []
 3:   print(toto);					-- [], [3]
 4:   toto := 'hello';			    -- [3], []
 5:   print(toto);					-- [3], [5]	-> before
 6:   if true then					-- [], [5]
 7:     print(toto);				-- [], [7]	-> condEval1
 8:   end if;						-- [3], [7]
 9:   print(toto);					-- [3], [9]
10: end;

-- cas if write
 1: begin
 2:   var toto := 'hello';			-- [], []
 3:   print(toto);					-- [], [3]
 4:   toto := 'hello';			    -- [3], []
 5:   print(toto);					-- [3], [5]	-> before
 6:   if true then					-- [], [5]
 7:     toto := hello;				-- [5], []	-> condEval1
 8:   end if;						-- 
 9:   print(toto);					-- 
10: end;
	
-- cas if/else read
 1: begin
 2:   var toto := 'hello';			-- [], []
 3:   print(toto);					-- [], [3]
 4:   toto := 'hello';			    -- [3], []
 5:   print(toto);					-- [3], [5]		-> before
 6:   if true then					-- [], [5]
 7:     print(toto);				-- [], [7]		-> condEval1
 8:   else							-- [], [5]
 9:     print(toto);				-- [], [9]		-> condEval2	
10:   end if;						-- [3], [7, 9]
11:   print(toto);					-- [3], [11]
12: end; 
		

	
	
Linear Type
===========

begin
  var toto := 'hello';
  var titi := toto || toto;   # illegal, toto is unset by first reference			
end;
		
begin
  var toto := 'hello';
  var titi := dup(toto) || toto;   # Ok, dup incremente the ref count			
end;


begin
  var toto := ['hello'];
  var titi := toto[0];				#			
end;
		
		
		
		
	
	
	
	
	
	
	
	
	
		
	
	
	










		
		
		
	
	
	
		 
	

































