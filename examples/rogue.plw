#############
###
### GEOMETRY
###

function min(a integer, b integer) integer begin
	if a < b then
		return a;
	end if;
	return b;
end min;

function max(a integer, b integer) integer begin
	if a > b then
		return a;
	end if;
	return b;
end max;

type point {
	x integer,
	y integer
};

type rect {
	x1 integer,
	y1 integer,
	x2 integer,
	y2 integer
};

function point_in_array(p point, a [point]) boolean begin
	for i in 0 .. last_index(a) loop
		if a[i] = p then
			return true;
		end if;
	end loop;
	return false;
end point_in_array;

function make_rect(x integer, y integer, w integer, h integer) rect begin
	return {x1: x, y1: y, x2: x + w, y2: y + h} as rect;
end make_rect;

function intersect(r1 rect, r2 rect) boolean begin
	return r1.x1 <= r2.x2 and r1.x2 >= r2.x1 and r1.y1 <= r2.y2 and r1.y2 >= r2.y1;
end intersect;

function center(r rect) point begin
	return {x: (r.x1 + r.x2) / 2, y: (r.y1 + r.y2) / 2} as point; 
end center;

type drawing_line {
	x integer,
	y integer,
	x1 integer,
	y1 integer,
	x2 integer,
	y2 integer,
	dx integer,
	sx integer,
	dy integer,
	sy integer,
	error integer,
	has_next boolean
};

function drawing_line(x1 integer, y1 integer, x2 integer, y2 integer) drawing_line begin
	return {
		x:  x1,
		y:  y1,
		x1: x1,
		y1: y1,
		x2: x2,
		y2: y2,
		dx: abs(x2 - x1),
		sx: case when x1 < x2 then 1 else -1 end,
		dy: -abs(y2 - y1),
		sy: case when y1 < y2 then 1 else -1 end,
		error: abs(x2 - x1) - abs(y2 - y1),
		has_next: true
	} as drawing_line;
end drawing_line;

function next(dl drawing_line) drawing_line begin
	dl.x := dl.x1;
	dl.y := dl.y1;
    if dl.x1 = dl.x2 and dl.y1 = dl.y2 then
    	dl.has_next := false;
   	else
	    var e2 := 2 * dl.error;
	    if e2 >= dl.dy then
	        if dl.x1 = dl.x2 then
	        	dl.has_next := false;
	        else
	        	dl.error := dl.error + dl.dy;
	        	dl.x1 := dl.x1 + dl.sx;
	        end if;
	    end if;
	    if e2 <= dl.dx then
	        if dl.y1 = dl.y2 then
	        	dl.has_next := false;
	        else
	        	dl.error := dl.error + dl.dx;
	        	dl.y1 := dl.y1 + dl.sy;
	        end if;
	    end if;
	end if;
	return dl;
end next;

#############
###
### TERMINAL
###

const SCREEN_WIDTH := 80;
const SCREEN_HEIGHT := 29;

const ANSI_CR := text([13 as char]);
const ANSI_LF := text([10 as char]);
const ANSI_CSI := text([27 as char]) || '[';
const ANSI_CLEAR_TERMINAL := ANSI_CSI || '0;0H' || ANSI_CSI || 'J';
const ANSI_HIDE_CURSOR := ANSI_CSI || '?25l';
const ANSI_SHOW_CURSOR := ANSI_CSI || '?25h';
const ANSI_RESET_COLOR := ANSI_CSI || '0m';
const ANSI_SGR_SEP := ';';
const ANSI_SGR_TERM := 'm';
const ANSI_FG_BLACK := '30';
const ANSI_FG_RED := '31';
const ANSI_FG_GREEN := '32';
const ANSI_FG_YELLOW := '33';
const ANSI_FG_BLUE := '34';
const ANSI_FG_MAGENTA := '35';
const ANSI_FG_CYAN := '36';
const ANSI_FG_WHITE := '37';
const ANSI_FG_BRIGHT_BLACK := '90';
const ANSI_FG_BRIGHT_RED := '91';
const ANSI_FG_BRIGHT_GREEN := '92';
const ANSI_FG_BRIGHT_YELLOW := '93';
const ANSI_FG_BRIGHT_BLUE := '94';
const ANSI_FG_BRIGHT_MAGENTA := '95';
const ANSI_FG_BRIGHT_CYAN := '96';
const ANSI_FG_BRIGHT_WHITE := '97';
const ANSI_BG_BLACK := '40';
const ANSI_BG_RED := '41';
const ANSI_BG_GREEN := '42';
const ANSI_BG_YELLOW := '43';
const ANSI_BG_BLUE := '44';
const ANSI_BG_MAGENTA := '45';
const ANSI_BG_CYAN := '46';
const ANSI_BG_WHITE := '47';
const ANSI_BG_BRIGHT_BLACK := '100';
const ANSI_BG_BRIGHT_RED := '101';
const ANSI_BG_BRIGHT_GREEN := '102';
const ANSI_BG_BRIGHT_YELLOW := '103';
const ANSI_BG_BRIGHT_BLUE := '104';
const ANSI_BG_BRIGHT_MAGENTA := '105';
const ANSI_BG_BRIGHT_CYAN := '106';
const ANSI_BG_BRIGHT_WHITE := '97';

function ansi_color(fg_color text, bg_color text) text begin
	return ANSI_CSI || fg_color || ';' || bg_color || 'm';
end ansi_color;

###########
###
### GLYPHS
###

const GLYPH_SPACE := ' ';
const GLYPH_PLAYER := '@';
const GLYPH_WALL := '#';
const GLYPH_FLOOR := '.';
const GLYPH_DOWNSTAIRS := '>';
const GLYPH_SWORD := '/';
const GLYPH_SHIELD := '(';
const GLYPH_SCROLL := ')';
const GLYPH_POTION := 'j';
const GLYPH_GOBELIN := 'g';
const GLYPH_ORC := 'o';
const GLYPH_TRAP := '^';

type screen_cell {
	glyph text,
	fg_color text,
	bg_color text
};

function screen_cell(glyph text, fg_color text, bg_color text) screen_cell begin
	return {glyph: glyph, fg_color: fg_color, bg_color: bg_color} as screen_cell;
end screen_cell;

const EMPTY_SCREEN_CELL := {glyph: GLYPH_SPACE, fg_color: ANSI_FG_WHITE, bg_color: ANSI_BG_BLACK} as screen_cell;
const FLOOR_SCREEN_CELL := {glyph: GLYPH_FLOOR, fg_color: ANSI_FG_BLUE, bg_color: ANSI_BG_BLACK} as screen_cell;
const WALL_SCREEN_CELL := {glyph: GLYPH_WALL, fg_color: ANSI_FG_GREEN, bg_color: ANSI_BG_BLACK} as screen_cell;
const DOWNSTAIRS_SCREEN_CELL := {glyph: GLYPH_DOWNSTAIRS, fg_color: ANSI_FG_CYAN, bg_color: ANSI_BG_BLACK} as screen_cell;

#############
###
### ENTITIES
###

const ENTITY_ID_NONE := -1;

type viewrange {
	range integer,
	flags [[boolean]],
	dirty boolean
};

function viewrange(range integer) viewrange begin
	return {range: range, flags: [] as [[boolean]], dirty: true} as viewrange;
end viewrange;

type combatstat {
	max_hp integer,
	hp integer,
	defense integer,
	power integer,
	confused_turns integer
};

type equip_slot integer;

const EQUIP_SLOT_NONE    := -1 as equip_slot;
const EQUIP_SLOT_MELEE   := 0 as equip_slot;
const EQUIP_SLOT_DEFENSE := 1 as equip_slot;
const EQUIP_SLOT_COUNT   := 2;
const EQUIP_SLOT_NAMES   := ['Melee', 'Defense'];

type item {
	owner_id         integer,
	equippable_slot  equip_slot,
	equipped         boolean
};

type potion {
	hp integer
};

type scroll {
	range           integer,
	damage          integer,
	effect_radius   integer,
	confusion_turns integer
};

type combat_bonus {
	defense_bonus	integer,
	power_bonus		integer
};

type entity {
	name				text,
	is_active			boolean,
	position			null|point,
	display				null|screen_cell,
	viewrange			null|viewrange,
	combat_stat			null|combatstat,
	blocks_tile			boolean, 
	item				null|item,
	potion				null|potion,
	scroll				null|scroll,
	combat_bonus		null|combat_bonus		
};

function entity(name text, position point, display screen_cell) entity begin
	return {
		name:			name,
		is_active:		true,
		position:		position 				as null|point,
		display:		display					as null|screen_cell,
		viewrange:   	null					as null|viewrange,
		combat_stat:	null					as null|combatstat,
		blocks_tile:	false,
		item:			null					as null|item,
		potion:			null					as null|potion,
		scroll:			null					as null|scroll,
		combat_bonus:	null					as null|combat_bonus
	} as entity;
end entity;

function fighter_entity(e entity, viewrange integer, max_hp integer, defense integer, power integer) entity begin
	e.viewrange   := {range: viewrange, flags: [] as [[boolean]], dirty: true} as viewrange as null|viewrange;
	e.combat_stat := {max_hp: max_hp, hp: max_hp, defense: defense, power: power, confused_turns: 0} as combatstat as null|combatstat;
	e.blocks_tile := true;
	return e;
end fighter_entity;

function equippable_item_entity(e entity, slot equip_slot, defense_bonus integer, power_bonus integer) entity begin
	e.item := {owner_id: ENTITY_ID_NONE, equippable_slot: slot, equipped: false} as item as null|item;
	e.combat_bonus := {defense_bonus: defense_bonus, power_bonus: power_bonus} as combat_bonus as null|combat_bonus;
	return e;
end equippable_item_entity;

function potion_entity(e entity, hp integer) entity begin
	e.item   := {owner_id: ENTITY_ID_NONE, equippable_slot: EQUIP_SLOT_NONE, equipped: false} as item as null|item;
	e.potion := {hp: hp} as potion as null|potion;
	return e;
end potion_entity;

function scroll_entity(e entity, range integer, damage integer, effect_radius integer, confusion_turns integer) entity begin
	e.item   := {owner_id: ENTITY_ID_NONE, equippable_slot: EQUIP_SLOT_NONE, equipped: false} as item as null|item;
	e.scroll := {range: range, damage: damage, effect_radius: effect_radius, confusion_turns: confusion_turns} as scroll as null|scroll;
	return e;
end scroll_entity;

procedure print_visibility_flags(flags [[boolean]]) begin
	for y in 0 .. last_index(flags) loop
		var line := '';
		for x in 0 .. last_index(flags[y]) loop
			line := line || case when flags[y][x] then 'X' else '.' end;
		end loop;
		print(line);
	end loop;
end print_visibility_flags;

function in_viewrange(p point, entity entity) boolean begin
	kindof entity.viewrange when viewrange vr then
		kindof entity.position when point pos then
			if p.x >= pos.x - vr.range and
			   p.x <= pos.x + vr.range and
			   p.y >= pos.y - vr.range and
			   p.y <= pos.y + vr.range
			then
				var rel_x := vr.range + p.x - pos.x;
				var rel_y := vr.range + p.y - pos.y;
				if rel_y < 0 or rel_y >= length(vr.flags) or
				   rel_x < 0 or rel_x >= length(vr.flags[rel_y])
				then
					return false;
				end if;
				return vr.flags[rel_y][rel_x];
			end if;
			return false;
		end;
	end;
	return false;
end in_viewrange;

type equipment {
	backpack_items [integer],
	equip_items [integer]
};

function find_equipment(entities [entity], entity_id integer) equipment begin
	var backpack_items := [] as [integer];
	var equip_items := ENTITY_ID_NONE ** EQUIP_SLOT_COUNT;
	for i in 0 .. last_index(entities) loop
		var entity := entities[i];
		kindof entity.item when item item then
			if item.owner_id = entity_id then
				if item.equipped then
					equip_items[item.equippable_slot as integer] := i;
				else
					backpack_items := backpack_items || [i];
				end if;
			end if;
		end;
	end loop;
	return {backpack_items: backpack_items, equip_items: equip_items} as equipment;
end find_equipment;

#############
###
### GAME LOG
###

const MAX_MESSAGES := 20;

function add_message(messages [text], msg text) [text] begin
	if length(messages) = MAX_MESSAGES then
		messages := messages[1 .. MAX_MESSAGES - 1];
	end if;
	messages := messages || [msg];
	return messages;
end add_message;

########
###
### MAP
###

type tile_type integer;

const TILE_FLOOR 		:= 0 as tile_type;
const TILE_WALL  		:= 1 as tile_type;
const TILE_DOWNSTAIRS	:= 2 as tile_type;

type map {
	depth integer,
	tiles [[tile_type]],
	revealed_tiles [[boolean]],
	visible_tiles [[boolean]],
	rooms [rect],
	width integer,
	height integer,
	blocking_entities [[integer]],
	nonblocking_entities [[integer]]
};

function tiles_with_room(tiles [[tile_type]], room rect) [[tile_type]] begin
	for y in room.y1 + 1 .. room.y2  loop
        for x in room.x1 + 1 .. room.x2 loop
            tiles[y][x] := TILE_FLOOR;
        end loop;
    end loop;
    return tiles;
end tiles_with_room;

function tiles_with_horizontal_tunnel(tiles [[tile_type]], x1 integer, x2 integer, y integer) [[tile_type]] begin
    for x in min(x1, x2) .. max(x1, x2) loop
		tiles[y][x] := TILE_FLOOR;
    end loop;
    return tiles;
end tiles_with_horizontal_tunnel;

function tiles_with_vertical_tunnel(tiles [[tile_type]], y1 integer, y2 integer, x integer) [[tile_type]] begin
    for y in min(y1, y2) .. max(y1, y2) loop
		tiles[y][x] := TILE_FLOOR;
	end loop;
	return tiles;
end tiles_with_vertical_tunnel;

function make_map(depth integer, width integer, height integer) map begin
	var tiles := TILE_WALL ** width ** height;
	var revealed_tiles := false ** width ** height;
	var visible_tiles := false ** width ** height;
	var blocking_entities := ENTITY_ID_NONE ** width ** height;
	var nonblocking_entities := ENTITY_ID_NONE ** width ** height;
	var rooms := [] as [rect];
    const MAX_ROOMS := 30;
    const MIN_SIZE := 6;
    const MAX_SIZE := 10;
    for i in 0 .. MAX_ROOMS - 1 loop
        var w := random(MIN_SIZE, MAX_SIZE);
        var h := random(MIN_SIZE, MAX_SIZE);
        var x := random(1, width - w - 1) - 1;
        var y := random(1, height - h - 1) - 1;
        var new_room := make_rect(x, y, w, h);
        var ok := true;
        for j in 0 .. last_index(rooms) loop
            if intersect(new_room, rooms[j]) then
            	ok := false;
            end if;
        end loop;
        if ok then
            tiles := tiles_with_room(tiles, new_room);
            if length(rooms) > 0 then
				var new_center := center(new_room);
        		var prev_center := center(rooms[last_index(rooms)]);
				if random(0, 2) = 1 then
            		tiles := tiles_with_horizontal_tunnel(tiles, prev_center.x, new_center.x, prev_center.y);
            		tiles := tiles_with_vertical_tunnel(tiles, prev_center.y, new_center.y, new_center.x);
				else
            		tiles := tiles_with_vertical_tunnel(tiles, prev_center.y, new_center.y, prev_center.x);
            		tiles := tiles_with_horizontal_tunnel(tiles, prev_center.x, new_center.x, new_center.y);
            	end if;
			end if;
            rooms := rooms || [new_room];            
        end if;
    end loop;
    var downstairs_pos := center(rooms[last_index(rooms)]);
    tiles[downstairs_pos.y][downstairs_pos.x] := TILE_DOWNSTAIRS;
	return {
		depth: depth,
		tiles: tiles,
		revealed_tiles: revealed_tiles,
		visible_tiles: visible_tiles,
		rooms: rooms,
		width: width,
		height: height,
		blocking_entities: blocking_entities,
		nonblocking_entities: nonblocking_entities
	} as map;
end make_map;

function map_is_blocked(map map, pos point) boolean begin
	return map.tiles[pos.y][pos.x] = TILE_WALL or map.blocking_entities[pos.y][pos.x] >= 0;
end map_is_blocked;

function visible_tile_flags(tiles [[tile_type]], x integer, y integer, range integer) [[boolean]] begin
	var flags := false ** (2 * range + 1) ** (2 * range + 1);
	for dir in 1..4 loop
		for i in 0 .. range * 2 loop
			var border_x := case when dir = 1 or dir = 3 then i when dir = 2 then 2 * range else 0 end;
			var border_y := case when dir = 2 or dir = 4 then i when dir = 3 then 2 * range else 0 end;
			var dl := drawing_line(range, range, border_x, border_y);
			while dl.has_next loop
				dl := next(dl);
				flags[dl.y][dl.x] := true;
				exit when tiles[y - range + dl.y][x - range + dl.x] = TILE_WALL;
				if dl.x > 0 then
					flags[dl.y][dl.x - 1] := true;
				end if;
				if dl.x < 2 * range then
					flags[dl.y][dl.x + 1] := true;
				end if;
				if dl.y > 0 then
					flags[dl.y - 1][dl.x] := true;
				end if;
				if dl.y < 2 * range then
					flags[dl.y + 1][dl.x] := true;
				end if;
			end loop;
		end loop;
	end loop;
	return flags;
end visible_tile_flags;

###############
###
### PATHFINDER
###

generator map_neighbors(map map, p point) point begin
	if p.y > 0 then
		yield {x: p.x, y: p.y - 1} as point;
	end if;
	if p.x < map.width - 1 then
		yield {x: p.x + 1, y: p.y} as point;
	end if;
	if p.y < map.height - 1 then
		yield {x: p.x, y: p.y + 1} as point;
	end if;
	if p.x > 0 then
		yield {x: p.x - 1, y: p.y} as point;
	end if;
	if p.x > 0 and p.y > 0 then
		yield {x: p.x - 1, y: p.y - 1} as point;
	end if;
	if p.x < map.width - 1 and p.y > 0 then
		yield {x: p.x + 1, y: p.y - 1} as point;
	end if;
	if p.x < map.width - 1 and  p.y < map.height - 1 then
		yield {x: p.x + 1, y: p.y + 1} as point;
	end if;
	if p.x > 0 and p.y < map.height - 1 then
		yield {x: p.x - 1, y: p.y + 1} as point;
	end if;
end map_neighbors;

function find_path(map map, start_pos point, end_pos point) [point] begin
	var frontier := [start_pos] as [point];
	var reached := false ** map.width ** map.height;
	var origins := {x: 0, y: 0} as point ** map.width ** map.height;
	while length(frontier) > 0 loop
		var new_frontier := [] as [point];
		for i in 0 .. last_index(frontier) loop
			for p in map_neighbors(map, frontier[i]) loop
				if p = end_pos then
					var path := [p];
					var origin := frontier[i];
					while origin <> start_pos loop
						path := [origin] || path;
						origin := origins[origin.y][origin.x];
					end loop;
					return path;
				elsif not reached[p.y][p.x] and not map_is_blocked(map, p) then
					reached[p.y][p.x] := true;
					origins[p.y][p.x] := frontier[i];
					new_frontier := new_frontier || [p];
				end if;
			end loop;
		end loop;
		frontier := new_frontier;
	end loop;
	return [] as [point];
end find_path;

############
###
### SPAWNER
###

function spawn_entity_id(entities [entity], map map, e entity)
	(entities [entity], map map, entity_id integer)
begin
	var entity_id := length(entities);
	entities := entities || [e];
	kindof e.position when point p then
		if e.blocks_tile then
			map.blocking_entities[p.y][p.x] := entity_id;
		else
			map.nonblocking_entities[p.y][p.x] := entity_id;
		end if;
	end;
	return (entities, map, entity_id);
end spawn_entity_id;

function spawn_entity(entities [entity], map map, e entity) (entities [entity], map map) begin
	var entity_id := 0;
	(entities, map, entity_id) := spawn_entity_id(entities, map, e);
	return (entities, map);
end spawn_entity;

function deactivate_entity(entities [entity], map map, entity_id integer) (entities [entity], map map) begin
	entities[entity_id].is_active := false;
	if entities[entity_id].blocks_tile then
		kindof entities[entity_id].position when point p then
			if map.blocking_entities[p.y][p.x] = entity_id then
				map.blocking_entities[p.y][p.x] := ENTITY_ID_NONE;
			end if;
		end;
	end if;
	kindof entities[entity_id].item when item item then
		item.owner_id := ENTITY_ID_NONE;
		entities[entity_id].item := item as null|item;
	end;
	return (entities, map);
end deactivate_entity;

function spawn_player(entities [entity], map map) (entities [entity], map map, player_id integer) begin
	var first_room := map.rooms[0];
	var player_pos := {x: random(first_room.x1 + 1, first_room.x2), y: random(first_room.y1 + 1, first_room.y2)} as point;
	return spawn_entity_id(entities, map,
		fighter_entity(
			entity('Player', player_pos, screen_cell(GLYPH_PLAYER, ANSI_FG_BRIGHT_YELLOW, ANSI_BG_BLACK)),
			8, 30, 2, 5));
end spawn_player;

function spawn_gobelin(entities [entity], map map, spawn_point point) (entities [entity], map map) begin
	return spawn_entity(entities, map,
		fighter_entity(entity('Gobelin', spawn_point, screen_cell(GLYPH_GOBELIN, ANSI_FG_BRIGHT_RED, ANSI_BG_BLACK)),
		8, 16, 1, 4));
end spawn_gobelin;

function spawn_orc(entities [entity], map map, spawn_point point) (entities [entity], map map) begin
	return spawn_entity(entities, map,
		fighter_entity(entity('Orc', spawn_point, screen_cell(GLYPH_ORC, ANSI_FG_BRIGHT_RED, ANSI_BG_BLACK)),
		8, 16, 1, 4));
end spawn_orc;

function spawn_lightning_scroll(entities [entity], map map, spawn_point point) (entities [entity], map map) begin
	return spawn_entity(entities, map, scroll_entity(
		entity('Lighning scroll', spawn_point, screen_cell(GLYPH_SCROLL, ANSI_FG_BRIGHT_CYAN, ANSI_BG_BLACK)),
		6, 20, 0, 0));
end spawn_lightning_scroll;

function spawn_fireball_scroll(entities [entity], map map, spawn_point point) (entities [entity], map map) begin
	return spawn_entity(entities, map, scroll_entity(
		entity('Fireball scroll', spawn_point, screen_cell(GLYPH_SCROLL, ANSI_FG_BRIGHT_RED, ANSI_BG_BLACK)),
		6, 20, 3, 0));
end spawn_fireball_scroll;

function spawn_confusion_scroll(entities [entity], map map, spawn_point point) (entities [entity], map map) begin
	return spawn_entity(entities, map, scroll_entity(
		entity('Confusion scroll', spawn_point, screen_cell(GLYPH_SCROLL, ANSI_FG_BRIGHT_MAGENTA, ANSI_BG_BLACK)),
		6, 0, 0, 4));
end spawn_confusion_scroll;

function spawn_sword(entities [entity], map map, spawn_point point) (entities [entity], map map) begin
	return spawn_entity(entities, map, equippable_item_entity(
		entity('Sword', spawn_point, screen_cell(GLYPH_SWORD, ANSI_FG_BRIGHT_CYAN, ANSI_BG_BLACK)),
		EQUIP_SLOT_MELEE, 0, 2));
end spawn_sword;

function spawn_long_sword(entities [entity], map map, spawn_point point) (entities [entity], map map) begin
	return spawn_entity(entities, map, equippable_item_entity(
		entity('Long sword', spawn_point, screen_cell(GLYPH_SWORD, ANSI_FG_BRIGHT_YELLOW, ANSI_BG_BLACK)),
		EQUIP_SLOT_MELEE, 0, 4));
end spawn_long_sword;

function spawn_shield(entities [entity], map map, spawn_point point) (entities [entity], map map) begin
	return spawn_entity(entities, map, equippable_item_entity(
		entity('Shield', spawn_point, screen_cell(GLYPH_SHIELD, ANSI_FG_BRIGHT_CYAN, ANSI_BG_BLACK)),
		EQUIP_SLOT_DEFENSE, 1, 0));
end spawn_shield;

function spawn_tower_shield(entities [entity], map map, spawn_point point) (entities [entity], map map) begin
	return spawn_entity(entities, map, equippable_item_entity(
		entity('Tower shield', spawn_point, screen_cell(GLYPH_SHIELD, ANSI_FG_BRIGHT_YELLOW, ANSI_BG_BLACK)),
		EQUIP_SLOT_DEFENSE, 3, 0));
end spawn_tower_shield;

function spawn_potion(entities [entity], map map, spawn_point point) (entities [entity], map map) begin
	return spawn_entity(entities, map, potion_entity(
		entity('Potion', spawn_point, screen_cell(GLYPH_POTION, ANSI_FG_BRIGHT_MAGENTA, ANSI_BG_BLACK)),
		8));
end spawn_potion;

function spawn_trap(entities [entity], map map, spawn_point point) (entities [entity], map map) begin
	return spawn_entity(entities, map, 
		entity('Trap', spawn_point, screen_cell(GLYPH_TRAP, ANSI_FG_RED, ANSI_BG_BLACK)));
end spawn_trap;

type spawn_id integer;
type spawn_weight {id spawn_id, weight integer};

function spawn_weight(id spawn_id, weight integer) spawn_weight begin
	return {id: id, weight: weight} as spawn_weight;
end spawn_weight;

function random_spawn_id(weights [spawn_weight]) spawn_id begin
	var total_weight := 0;
	for w in weights loop
		if w.weight > 0 then
			total_weight := total_weight + w.weight;
		end if;
	end loop;
	var dice := random(0, total_weight - 1);
	for i in 0 .. last_index(weights) - 1 loop
		if weights[i].weight > 0 then
			if dice < weights[i].weight then
				return weights[i].id;
			end if;
			dice := dice - weights[i].weight;
		end if;
	end loop;
	return weights[last_index(weights)].id;
end random_spawn_id;

const SPAWN_GOBELIN             := 0 as spawn_id;
const SPAWN_ORC                 := 1 as spawn_id;
const SPAWN_POTION              := 2 as spawn_id;
const SPAWN_FIREBALL_SCROLL     := 3 as spawn_id;
const SPAWN_CONFUSION_SCROLL    := 4 as spawn_id;
const SPAWN_LIGHTNING_SCROLL    := 5 as spawn_id;
const SPAWN_SWORD               := 6 as spawn_id;
const SPAWN_SHIELD              := 7 as spawn_id;
const SPAWN_LONG_SWORD          := 8 as spawn_id;
const SPAWN_TOWER_SHIELD        := 9 as spawn_id;
const SPAWN_TRAP                := 10 as spawn_id;

function spawn_weigths(depth integer) [spawn_weight] begin
	return [
		spawn_weight(SPAWN_GOBELIN,          10),
		spawn_weight(SPAWN_ORC,    			  1 + depth),
		spawn_weight(SPAWN_POTION,            7),
		spawn_weight(SPAWN_FIREBALL_SCROLL,   2 + depth),
		spawn_weight(SPAWN_CONFUSION_SCROLL,  2 + depth),
		spawn_weight(SPAWN_LIGHTNING_SCROLL,  4),
		spawn_weight(SPAWN_SWORD,             3),
		spawn_weight(SPAWN_SHIELD,            3),
		spawn_weight(SPAWN_LONG_SWORD,        depth - 1),
		spawn_weight(SPAWN_TOWER_SHIELD,      depth - 1),
		spawn_weight(SPAWN_TRAP,      		  1)
	];
end spawn_weigths;

function spawn_random_entity(entities [entity], map map, spawn_point point, weights [spawn_weight])
	(entities [entity], map map)
begin
	var id := random_spawn_id(weights);
	if    id = SPAWN_GOBELIN          then (entities, map) := spawn_gobelin(entities, map, spawn_point);
	elsif id = SPAWN_ORC              then (entities, map) := spawn_orc(entities, map, spawn_point);
	elsif id = SPAWN_POTION           then (entities, map) := spawn_potion(entities, map, spawn_point);
	elsif id = SPAWN_FIREBALL_SCROLL  then (entities, map) := spawn_fireball_scroll(entities, map, spawn_point);
	elsif id = SPAWN_CONFUSION_SCROLL then (entities, map) := spawn_confusion_scroll(entities, map, spawn_point);
	elsif id = SPAWN_LIGHTNING_SCROLL then (entities, map) := spawn_lightning_scroll(entities, map, spawn_point);
	elsif id = SPAWN_SWORD            then (entities, map) := spawn_sword(entities, map, spawn_point);
	elsif id = SPAWN_SHIELD           then (entities, map) := spawn_shield(entities, map, spawn_point);
	elsif id = SPAWN_LONG_SWORD       then (entities, map) := spawn_long_sword(entities, map, spawn_point);
	elsif id = SPAWN_TOWER_SHIELD     then (entities, map) := spawn_tower_shield(entities, map, spawn_point);
	elsif id = SPAWN_TRAP     		  then (entities, map) := spawn_trap(entities, map, spawn_point);
	end if;
	return (entities, map);
end spawn_random_entity;

function populate_room(entities [entity], map map, room rect, weights [spawn_weight])
	(entities [entity], map map)
begin
	var spawn_points := [] as [point];
	var spawn_num := random(1, 7) + map.depth - 4;
	for i in 1 .. spawn_num loop
		var spawn_point := {x: random(room.x1 + 1, room.x2), y: random(room.y1 + 1, room.y2)} as point;
		if not point_in_array(spawn_point, spawn_points) then
			(entities, map) := spawn_random_entity(entities, map, spawn_point, weights);
			spawn_points := spawn_points || [spawn_point];
		end if;
	end loop;
	return (entities, map);
end populate_room;

function populate_map(entities [entity], map map)
	(entities [entity], map map)
begin
	var weights := spawn_weigths(map.depth);
	for i in 1 .. last_index(map.rooms) loop
		(entities, map) := populate_room(entities, map, map.rooms[i], weights);
	end loop;
	return (entities, map);
end populate_map;

############
###
### DISPLAY
###

const CHAR_SPACE := char_at(' ', 0);

function render(screen [[screen_cell]], entities [entity], map map) [[screen_cell]] begin
	for y in 0 .. SCREEN_HEIGHT - 1 loop
		var visible_tiles := map.visible_tiles[y];
		var revealed_tiles := map.revealed_tiles[y];
		var tiles := map.tiles[y];
		var blocking_entities := map.blocking_entities[y];
		var nonblocking_entities := map.nonblocking_entities[y];
		for x in 0 .. SCREEN_WIDTH - 1 loop
			if visible_tiles[x] or revealed_tiles[x] then
				screen[y][x] := case tiles[x]
					when TILE_FLOOR      then FLOOR_SCREEN_CELL
					when TILE_WALL       then WALL_SCREEN_CELL
					when TILE_DOWNSTAIRS then DOWNSTAIRS_SCREEN_CELL
					else EMPTY_SCREEN_CELL
				end;
				if visible_tiles[x] then
					var entity_id := blocking_entities[x];
					if entity_id < 0 or entities[entity_id].display = null as null|screen_cell then
						entity_id := nonblocking_entities[x];
					end if;
					if entity_id >= 0 then
						kindof entities[entity_id].display when screen_cell d then
							screen[y][x].glyph := d.glyph;
							screen[y][x].fg_color := d.fg_color;
							screen[y][x].bg_color := d.bg_color;
						end;
					end if;
				else
					screen[y][x].fg_color := ANSI_FG_WHITE;
				end if;
			else
				screen[y][x] := EMPTY_SCREEN_CELL;
			end if;
		end loop;
	end loop;
	return screen;
end render;

function screen_line_to_text(line [screen_cell]) text begin
	var t := ansi_color(ANSI_FG_WHITE, ANSI_BG_BLACK);
	var last_fg := ANSI_FG_WHITE;
	var last_bg := ANSI_BG_BLACK;
	for i in 0 .. last_index(line) loop
		var r := line[i];
		if r.fg_color <> last_fg then
			if r.bg_color <> last_bg then
				t := t || ANSI_CSI || r.fg_color || ANSI_SGR_SEP || r.bg_color || ANSI_SGR_TERM;
				last_fg := r.fg_color;
				last_bg := r.bg_color;
			else
				t := t || ANSI_CSI || r.fg_color || ANSI_SGR_TERM;
				last_fg := r.fg_color;
			end if;
		elsif r.bg_color <> last_bg then
			t := t || ANSI_CSI || r.bg_color || ANSI_SGR_TERM;
			last_bg := r.bg_color;
		end if;
		t := t || r.glyph;
	end loop;
	return t;
end screen_line_to_text;

procedure display(screen [[screen_cell]], depth integer, player entity, messages [text]) begin
	var s := ANSI_HIDE_CURSOR || ANSI_CLEAR_TERMINAL;
	for i in 0 .. last_index(screen) loop
		s := s || screen_line_to_text(screen[i]) || ANSI_CR || ANSI_LF;
	end loop;
	kindof player.combat_stat when combatstat cs then
		var status_line := 'Depth: ' || text(depth) || '    Health: ' || text(cs.hp) || '/' || text(cs.max_hp);
		status_line := status_line || text(CHAR_SPACE ** (SCREEN_WIDTH - length(status_line)));
		s := s || ansi_color(ANSI_FG_YELLOW, ANSI_BG_BLUE) || status_line || ansi_color(ANSI_FG_WHITE, ANSI_BG_BLACK);
	end;
	for i in max(0, length(messages) - 4) .. last_index(messages) loop
		s := s || ANSI_CR || ANSI_LF || messages[i];
	end loop;
	write(s);
end display;

###############
###
### GAME LOGIC
###

function move_entity(entities [entity], map map, entity_id integer, pos point)
	(entities [entity], map map)
begin
	kindof entities[entity_id].position when point old_pos then
		if not map_is_blocked(map, pos) then
			if map.blocking_entities[old_pos.y][old_pos.x] = entity_id then
				map.blocking_entities[old_pos.y][old_pos.x] := ENTITY_ID_NONE;
			end if;
			entities[entity_id].position := pos as null|point;
			if entities[entity_id].blocks_tile then
				map.blocking_entities[pos.y][pos.x] := entity_id;
			end if;
			kindof entities[entity_id].viewrange when viewrange vr then
				vr.dirty := true;
				entities[entity_id].viewrange := vr as null|viewrange;
			end;
		end if;
	end;
	return (entities, map);
end move_entity;

function attack_entity(entities [entity], map map, messages [text], attacker_id integer, target_id integer)
	(entities [entity], map map, messages [text])
begin
	var attacker := entities[attacker_id];
	var target := entities[target_id];
	kindof attacker.combat_stat when combatstat attacker_stat then
		kindof target.combat_stat when combatstat target_stat then
			var power_bonus := 0;
			var defense_bonus := 0;
			for i in 0 .. last_index(entities) loop
				kindof entities[i].item when item item then
					if item.owner_id = attacker_id and item.equipped then
						kindof entities[i].combat_bonus when combat_bonus cb then
							power_bonus := power_bonus + cb.power_bonus;
						end;
					elsif item.owner_id = target_id and item.equipped then
						kindof entities[i].combat_bonus when combat_bonus cb then
							defense_bonus := defense_bonus + cb.defense_bonus;
						end;
					end if;
				end;
			end loop;
			var damage := attacker_stat.power + power_bonus - target_stat.defense - defense_bonus;
			if damage < 0 then
				damage := 0;
			end if;
			target_stat.hp := target_stat.hp - damage;
			entities[target_id].combat_stat := target_stat as null|combatstat;
			messages := add_message(messages, attacker.name || ' dealt ' || text(damage) || ' damage to ' || target.name);
			if target_stat.hp <= 0 then
				(entities, map) := deactivate_entity(entities, map, target_id);
			end if;
		end;
	end;
	return (entities, map, messages);
end attack_entity;

function move_player(entities [entity], map map, messages [text], player_id integer, dx integer, dy integer)
	(entities [entity], map map, messages [text])
begin
	kindof entities[player_id].position when point p then
		p.x := p.x + dx;
		p.y := p.y + dy;
		var target_entity_id := map.blocking_entities[p.y][p.x];
		if target_entity_id <> ENTITY_ID_NONE then
			(entities, map, messages) := attack_entity(entities, map, messages, player_id, target_entity_id);
		else
			(entities, map) := move_entity(entities, map, player_id, p);
		end if;
	end;
	return (entities, map, messages);
end move_player;

function pickup_item(entities [entity], map map, messages [text], player_id integer)
	(entities [entity], map map, messages [text])
begin
	kindof entities[player_id].position when point p then
		var picked_id := map.nonblocking_entities[p.y][p.x];
		if picked_id = ENTITY_ID_NONE then
			messages := add_message(messages, 'Nothing to pick');
		else
			kindof entities[picked_id].item
			when item item then
				map.nonblocking_entities[p.y][p.x] := ENTITY_ID_NONE;
				item.owner_id := player_id;
				entities[picked_id].item := item as null|item;
				entities[picked_id].position := null as null|point;
				map.nonblocking_entities[p.y][p.x] := ENTITY_ID_NONE;
				messages := add_message(messages, entities[player_id].name || ' picked ' || entities[picked_id].name);
			else
				messages := add_message(messages, 'You can''t pick ' || entities[picked_id].name);
			end;
		end if;
	end;
	return (entities, map, messages);
end pickup_item;

function equip_item(entities [entity], item_id integer) [entity] begin
	kindof entities[item_id].item when item item then
		var owner_id := item.owner_id;
		if owner_id = ENTITY_ID_NONE then
			return entities;
		end if;
		if item.equippable_slot = EQUIP_SLOT_NONE then
			return entities;
		end if;
		var equipment := find_equipment(entities, owner_id);
		var already_equip_item_id := equipment.equip_items[item.equippable_slot as integer];
		if already_equip_item_id <> ENTITY_ID_NONE then
			kindof entities[already_equip_item_id].item when item ei then
				ei.equipped := false;
				entities[already_equip_item_id].item := ei as null|item;
			end;
		end if;
		item.equipped := true;
		entities[item_id].item := item as null|item;
	end;
	return entities;
end equip_item;

function update_viewranges(entities [entity], map map, player_id integer)
	(entities [entity], map map)
begin
	for i in 0 .. last_index(entities) loop
		const entity := entities[i];
		if entity.is_active then
			kindof entity.viewrange when viewrange r then
				if r.dirty then
					kindof entity.position when point p then
						r.flags := visible_tile_flags(map.tiles, p.x, p.y, r.range);
						r.dirty := false;
						entities[i].viewrange := r as null|viewrange;
						if i = player_id then
							map.visible_tiles := false ** map.width ** map.height;
							for y in 0 .. 2 * r.range loop
								var map_y := p.y + y - r.range;
								var flags := r.flags[y];
								for x in 0 .. 2 * r.range loop
									var map_x := p.x + x - r.range;
									if flags[x] and map_x >= 0 and map_x < map.width and map_y >= 0 and map_y < map.height then
										map.revealed_tiles[map_y][map_x] := true;
										map.visible_tiles[map_y][map_x] := true;
									end if;
								end loop;
							end loop; 
						end if;
					end;
				end if;
			end;
		end if;
	end loop;
	return (entities, map);
end update_viewranges;

function animate_fighters(entities [entity], map map, messages [text], player_id integer)
	(entities [entity], map map, messages [text])
begin
	for i in 0 .. last_index(entities) loop
		if i <> player_id then
			const entity := entities[i];
			if entity.is_active then
				kindof entity.combat_stat when combatstat cs then
					if cs.confused_turns > 0 then
						cs.confused_turns := cs.confused_turns - 1;
						entities[i].combat_stat := cs as null|combatstat;
					else
						kindof entity.position when point p then
							kindof entities[player_id].position when point player_pos then
								if entities[player_id].is_active and in_viewrange(player_pos, entities[i]) then
									var path := find_path(map, p, player_pos);
									if length(path) > 0 then
										var next_pos := path[0];
										if next_pos = player_pos then
											(entities, map, messages) := attack_entity(entities, map, messages, i, player_id);
										elsif not map_is_blocked(map, next_pos) then
											(entities, map) := move_entity(entities, map, i, next_pos);
										end if;
									else
										messages := add_message(messages, entity.name || ': come here if you''re a man');
									end if;
								end if;
							end;
						end;
					end if;
				end;
			end if;
		end if;
	end loop;
	return (entities, map, messages);	
end animate_fighters;

function heal_entity(entities [entity], entity_id integer, hp integer) [entity] begin
	kindof entities[entity_id].combat_stat when combatstat cs then
		cs.hp := cs.hp + hp;
		if cs.hp > cs.max_hp then
			cs.hp := cs.max_hp;
		end if;
		entities[entity_id].combat_stat := cs as null|combatstat;
	end;
	return entities;
end heal_entity;

function entity_use_item(screen any, entities [entity], map map, messages[text], entity_id integer, item_id integer)
	(entities [entity], map map, messages [text])
begin
	kindof entities[item_id].potion when potion p then
		entities := heal_entity(entities, entity_id, p.hp);
		(entities, map) := deactivate_entity(entities, map, item_id);
		messages := add_message(messages, entities[entity_id].name || ' used ' || entities[item_id].name);
	end;
	kindof entities[item_id].scroll when scroll s then
		var target_pos := choose_target_position(screen, entities, map, messages, entity_id, s.range);
		kindof target_pos when point p then
			messages := add_message(messages, entities[entity_id].name || ' used ' || entities[item_id].name);
			for y in p.y - s.effect_radius .. p.y + s.effect_radius loop
				for x in p.x - s.effect_radius .. p.x + s.effect_radius loop
					var target_id := map.blocking_entities[y][x];
					if target_id <> ENTITY_ID_NONE then
						kindof entities[target_id].combat_stat when combatstat cs then
							if s.damage > 0 then
								cs.hp := cs.hp - s.damage;
								messages := add_message(messages,
									entities[entity_id].name || ' dealt ' || text(s.damage) || ' damage to ' || entities[target_id].name);
							end if;
							if s.confusion_turns > 0 and cs.confused_turns < s.confusion_turns then
								cs.confused_turns := s.confusion_turns;
								messages := add_message(messages,
									entities[entity_id].name || ' confused ' || entities[target_id].name ||
										' for ' || text(s.confusion_turns) || ' turns');
							end if;
							entities[target_id].combat_stat := cs as null|combatstat;
							if cs.hp <= 0 then
								(entities, map) := deactivate_entity(entities, map, target_id);
							end if;
						end;
					end if;
				end loop;
			end loop;
			(entities, map) := deactivate_entity(entities, map, item_id);
		end;
	end;
	return (entities, map, messages);
end entity_use_item;

function go_next_level(entities [entity], map map, messages [text], player_id integer)
	(entities [entity], map map, messages [text], player_id integer)
begin
	var can_descend := false;
	kindof entities[player_id].position when point p then
		if map.tiles[p.y][p.x] = TILE_DOWNSTAIRS then
			can_descend := true;
		end if;
	end;
	if not can_descend then
		messages := add_message(messages, 'You cannot descend to the new level here');
		return (entities, map, messages, player_id);
	end if;
	var new_player_id := 0;
	var new_entities := [] as [entity];
	for i in 0 .. last_index(entities) loop
		if i = player_id then
			new_entities := new_entities || [entities[i]];
			new_player_id := last_index(new_entities);
		elsif entities[i].is_active then
			kindof entities[i].item when item itm then
				if itm.owner_id = player_id then
					new_entities := new_entities || [entities[i]];
				end if;
			end;
		end if;
	end loop;
	player_id := new_player_id;
	entities := new_entities;
	map := make_map(map.depth + 1, SCREEN_WIDTH, SCREEN_HEIGHT);
	var first_room := map.rooms[0];
	var player_pos := {x: random(first_room.x1 + 1, first_room.x2), y: random(first_room.y1 + 1, first_room.y2)} as point;
	map.blocking_entities[player_pos.y][player_pos.x] := player_id;
	entities[player_id].position := player_pos as null|point;
	kindof entities[player_id].viewrange when viewrange vr then
		vr.dirty := true;
		entities[player_id].viewrange := vr as null|viewrange;
	end;
	(entities, map) := populate_map(entities, map);
	messages := add_message(messages, 'You descend to the new level');
	return (entities, map, messages, player_id);
end go_next_level;

#####################
###
### GAME INPUT LOOPS
###

const IN_CHAR_UP := char_at('i', 0);
const IN_CHAR_DOWN := char_at('k', 0);
const IN_CHAR_LEFT := char_at('j', 0);
const IN_CHAR_RIGHT := char_at('l', 0);
const IN_CHAR_QUIT := char_at('x', 0);
const IN_CHAR_UPRIGHT := char_at('o', 0);
const IN_CHAR_UPLEFT := char_at('u', 0);
const IN_CHAR_DOWNRIGHT := char_at(';', 0);
const IN_CHAR_DOWNLEFT := char_at(',', 0);
const IN_CHAR_PICKUP := char_at(' ', 0);
const IN_CHAR_INVENTORY := char_at('y', 0);
const IN_CHAR_DOWNSTAIRS := char_at('n', 0);
const IN_CHAR_SKIPTURN := char_at('p', 0);

function choose_target_position(screen [[screen_cell]], entities [entity], map map, messages [text], player_id integer, range integer)
	null|point
begin
	kindof entities[player_id].position when point pos then
		var target_pos := pos;
		while true loop
			screen := render(screen, entities, map);
			screen[target_pos.y][target_pos.x].bg_color := ANSI_BG_CYAN;
			display(screen, map.depth, entities[player_id], messages);
			var new_pos := target_pos;
			var input := get_char();
			if input = IN_CHAR_UP then
				new_pos.y := new_pos.y - 1;
			elsif input = IN_CHAR_DOWN then
				new_pos.y := new_pos.y + 1;
			elsif input = IN_CHAR_LEFT then
				new_pos.x := new_pos.x - 1;
			elsif input = IN_CHAR_RIGHT then
				new_pos.x := new_pos.x + 1;
			elsif input = IN_CHAR_UPRIGHT then
				new_pos.y := new_pos.y - 1;
				new_pos.x := new_pos.x + 1;
			elsif input = IN_CHAR_UPLEFT then
				new_pos.y := new_pos.y - 1;
				new_pos.x := new_pos.x - 1;
			elsif input = IN_CHAR_DOWNRIGHT then
				new_pos.y := new_pos.y + 1;
				new_pos.x := new_pos.x + 1;
			elsif input = IN_CHAR_DOWNLEFT then
				new_pos.y := new_pos.y + 1;
				new_pos.x := new_pos.x - 1;
			elsif input = IN_CHAR_PICKUP then
				return target_pos as null|point;
			elsif input = IN_CHAR_QUIT then
				exit;
			end if;
			if new_pos.x >= pos.x - range and new_pos.x <= pos.x + range and
			   new_pos.y >= pos.y - range and new_pos.y <= pos.y + range and 
			   in_viewrange(new_pos, entities[player_id])
			then
				target_pos := new_pos;
			end if;
		end loop;
	end;
	return null as null|point;
end choose_target_position;

function choose_inventory_item(entities [entity], player_id integer)
	(entities [entity], item_id integer)
begin
	while true loop
		var equipment := find_equipment(entities, player_id);
		print(ANSI_HIDE_CURSOR || ANSI_CLEAR_TERMINAL || 'Backpack (' || text(length(equipment.backpack_items)) || ' items):' || ANSI_CR);			
		for i in 0 .. last_index(equipment.backpack_items) loop
			print(text(i + 1) || ': ' || entities[equipment.backpack_items[i]].name || ANSI_CR);
		end loop;
		print('');
		print('Equipped:' || ANSI_CR);
		for i in 0 .. EQUIP_SLOT_COUNT - 1 loop
			var slot_name := EQUIP_SLOT_NAMES[i];
			var item_name := case equipment.equip_items[i]
				when ENTITY_ID_NONE then 'none'
				else entities[equipment.equip_items[i]].name
			end;
			print(slot_name || ': ' || item_name || ANSI_CR);
		end loop;
		print('');
		print('x: Exit inventory' || ANSI_CR);
		var input := get_char();
		exit when input = IN_CHAR_QUIT;
		var item_num := input as integer - char_code('1', 0);
		if item_num >= 0 and item_num < 9 and item_num < length(equipment.backpack_items) then
			var item_id := equipment.backpack_items[item_num];
			kindof entities[item_id].item when item item then
				if item.equippable_slot <> EQUIP_SLOT_NONE then
					entities := equip_item(entities, item_id);
					item_id := ENTITY_ID_NONE;
				end if;
			end;
			if item_id <> ENTITY_ID_NONE then
				return (entities, item_id);
			end if;
		end if;
	end loop;
	return (entities, ENTITY_ID_NONE);
end choose_inventory_item;

procedure game_over_loop() begin
	print(ANSI_HIDE_CURSOR || ANSI_CLEAR_TERMINAL || 'You died, game over.' || ANSI_CR);			
	var input := get_char();
end game_over_loop;

procedure main_loop() begin
	var entities := [] as [entity];
	var screen := EMPTY_SCREEN_CELL ** SCREEN_WIDTH ** SCREEN_HEIGHT;
	var messages := [] as [text];
	var map := make_map(1, SCREEN_WIDTH, SCREEN_HEIGHT);
	var player_id := 0;
	(entities, map, player_id) := spawn_player(entities, map);
	(entities, map) := populate_map(entities, map);
	var frame_count := 0;
	var viewrange_tick_time := 0;
	var monster_tick_time := 0;
	var render_time := 0;
	var display_time := 0;
	var exit_main_loop := false;
	while not exit_main_loop loop
		frame_count := frame_count + 1;
		var t1 := now();
		(entities, map) := update_viewranges(entities, map, player_id);
		var t2 := now();
		(entities, map, messages) := animate_fighters(entities, map, messages, player_id);
		var t3 := now();
		if not entities[player_id].is_active then
			game_over_loop();
			exit;
		end if;
		screen := render(screen, entities, map);
		var t4 := now();
		display(screen, map.depth, entities[player_id], messages);
		var t5 := now();
		viewrange_tick_time := viewrange_tick_time + t2 - t1;
		monster_tick_time := monster_tick_time + t3 - t2;
		render_time := render_time + t4 - t3;
		display_time := display_time + t5 - t4; 
		var exit_input_loop := false;
		while not exit_input_loop loop
			exit_input_loop := true;
			var input := get_char();
			if input = IN_CHAR_UP then
				(entities, map, messages) := move_player(entities, map, messages, player_id, 0, -1);
			elsif input = IN_CHAR_DOWN then
				(entities, map, messages) := move_player(entities, map, messages, player_id, 0, 1);
			elsif input = IN_CHAR_LEFT then
				(entities, map, messages) := move_player(entities, map, messages, player_id, -1, 0);
			elsif input = IN_CHAR_RIGHT then
				(entities, map, messages) := move_player(entities, map, messages, player_id, 1, 0);
			elsif input = IN_CHAR_UPRIGHT then
				(entities, map, messages) := move_player(entities, map, messages, player_id, 1, -1);
			elsif input = IN_CHAR_UPLEFT then
				(entities, map, messages) := move_player(entities, map, messages, player_id, -1, -1);
			elsif input = IN_CHAR_DOWNRIGHT then
				(entities, map, messages) := move_player(entities, map, messages, player_id, 1, 1);
			elsif input = IN_CHAR_DOWNLEFT then
				(entities, map, messages) := move_player(entities, map, messages, player_id, -1, 1);
			elsif input = IN_CHAR_PICKUP then
				(entities, map, messages) := pickup_item(entities, map, messages, player_id);
			elsif input = IN_CHAR_INVENTORY then
				var item_id := ENTITY_ID_NONE;
				(entities, item_id) := choose_inventory_item(entities, player_id);
				if item_id <> ENTITY_ID_NONE then
					(entities, map, messages) := entity_use_item(screen, entities, map, messages, player_id, item_id);
				end if;
			elsif input = IN_CHAR_DOWNSTAIRS then
				(entities, map, messages, player_id) := go_next_level(entities, map, messages, player_id);
			elsif input = IN_CHAR_SKIPTURN then
				messages := add_message(messages, 'Player skip his turn');
				entities := heal_entity(entities, player_id, 1);
			elsif input = IN_CHAR_QUIT then
				exit_main_loop := true;
			else
				messages := add_message(messages, 'Unknown input ' || text(input as integer));
				display(screen, map.depth, entities[player_id], messages);
				exit_input_loop := false;
			end if;
		end loop;
	end loop;
	write(ANSI_CLEAR_TERMINAL || ANSI_SHOW_CURSOR || ANSI_RESET_COLOR);
	print('frame_count             : ' || text(frame_count));
	print('viewrange_tick_time     : ' || text(viewrange_tick_time / frame_count));
	print('monster_tick_time       : ' || text(monster_tick_time / frame_count));
	print('render_time             : ' || text(render_time / frame_count));
	print('display_time            : ' || text(display_time / frame_count));
end main_loop;

main_loop();



