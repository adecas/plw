#############
###
### GEOMETRY
###

function min(a integer, b integer) integer begin
	if a < b then
		return a;
	end if;
	return b;
end min;

function max(a integer, b integer) integer begin
	if a > b then
		return a;
	end if;
	return b;
end max;

type point {
	x integer,
	y integer
};

type rect {
	x1 integer,
	y1 integer,
	x2 integer,
	y2 integer
};

function point_in_array(p point, a [point]) boolean begin
	for i in 0 .. last_index(a) loop
		if a[i] = p then
			return true;
		end if;
	end loop;
	return false;
end point_in_array;

function make_rect(x integer, y integer, w integer, h integer) rect begin
	return {x1: x, y1: y, x2: x + w, y2: y + h} as rect;
end make_rect;

function intersect(r1 rect, r2 rect) boolean begin
	return r1.x1 <= r2.x2 and r1.x2 >= r2.x1 and r1.y1 <= r2.y2 and r1.y2 >= r2.y1;
end intersect;

function center(r rect) point begin
	return {x: (r.x1 + r.x2) / 2, y: (r.y1 + r.y2) / 2} as point; 
end center;

type line_dots_context {
	x1 integer,
	y1 integer,
	x2 integer,
	y2 integer,
	dx integer,
	sx integer,
	dy integer,
	sy integer,
	error integer,
	again boolean
};

function line_dots_init(x1 integer, y1 integer, x2 integer, y2 integer) line_dots_context begin
	return {
		x1: x1,
		y1: y1,
		x2: x2,
		y2: y2,
		dx: abs(x2 - x1),
		sx:  case when x1 < x2 then 1 else -1 end,
		dy: -abs(y2 - y1),
		sy: case when y1 < y2 then 1 else -1 end,
		error: abs(x2 - x1) - abs(y2 - y1),
		again: true
	} as line_dots_context;
end line_dots_init;

function line_dots_next(ctx ldc line_dots_context) {x integer, y integer} begin
	var result := {x: ldc.x1, y: ldc.y1};
    if ldc.x1 = ldc.x2 and ldc.y1 = ldc.y2 then
    	ldc.again := false;
   	else
	    var e2 := 2 * ldc.error;
	    if e2 >= ldc.dy then
	        if ldc.x1 = ldc.x2 then
	        	ldc.again := false;
	        else
	        	ldc.error := ldc.error + ldc.dy;
	        	ldc.x1 := ldc.x1 + ldc.sx;
	        end if;
	    end if;
	    if e2 <= ldc.dx then
	        if ldc.y1 = ldc.y2 then
	        	ldc.again := false;
	        else
	        	ldc.error := ldc.error + ldc.dx;
	        	ldc.y1 := ldc.y1 + ldc.sy;
	        end if;
	    end if;
	end if;
	return result;
end line_dots_next;

#############
###
### TERMINAL
###

const SCREEN_WIDTH := 130;
const SCREEN_HEIGHT := 30;

const ANSI_CR := text([13 as char]);
const ANSI_LF := text([10 as char]);
const ANSI_CSI := text([27 as char]) || '[';
const ANSI_CLEAR_TERMINAL := ANSI_CSI || '0;0H' || ANSI_CSI || 'J';
const ANSI_HIDE_CURSOR := ANSI_CSI || '?25l';
const ANSI_SHOW_CURSOR := ANSI_CSI || '?25h';
const ANSI_RESET_COLOR := ANSI_CSI || '0m';
const ANSI_SGR_SEP := ';';
const ANSI_SGR_TERM := 'm';
const ANSI_FG_BLACK := '30';
const ANSI_FG_RED := '31';
const ANSI_FG_GREEN := '32';
const ANSI_FG_YELLOW := '33';
const ANSI_FG_BLUE := '34';
const ANSI_FG_MAGENTA := '35';
const ANSI_FG_CYAN := '36';
const ANSI_FG_WHITE := '37';
const ANSI_FG_BRIGHT_BLACK := '90';
const ANSI_FG_BRIGHT_RED := '91';
const ANSI_FG_BRIGHT_GREEN := '92';
const ANSI_FG_BRIGHT_YELLOW := '93';
const ANSI_FG_BRIGHT_BLUE := '94';
const ANSI_FG_BRIGHT_MAGENTA := '95';
const ANSI_FG_BRIGHT_CYAN := '96';
const ANSI_FG_BRIGHT_WHITE := '97';
const ANSI_BG_BLACK := '40';
const ANSI_BG_RED := '41';
const ANSI_BG_GREEN := '42';
const ANSI_BG_YELLOW := '43';
const ANSI_BG_BLUE := '44';
const ANSI_BG_MAGENTA := '45';
const ANSI_BG_CYAN := '46';
const ANSI_BG_WHITE := '47';
const ANSI_BG_BRIGHT_BLACK := '100';
const ANSI_BG_BRIGHT_RED := '101';
const ANSI_BG_BRIGHT_GREEN := '102';
const ANSI_BG_BRIGHT_YELLOW := '103';
const ANSI_BG_BRIGHT_BLUE := '104';
const ANSI_BG_BRIGHT_MAGENTA := '105';
const ANSI_BG_BRIGHT_CYAN := '106';
const ANSI_BG_BRIGHT_WHITE := '97';

function ansi_color(fg_color text, bg_color text) text begin
	return ANSI_CSI || fg_color || ';' || bg_color || 'm';
end ansi_color;

###########
###
### GLYPHS
###

const GLYPH_SPACE := ' ';
const GLYPH_PLAYER := '@';
const GLYPH_WALL := '#';
const GLYPH_FLOOR := '.';
const GLYPH_DOWNSTAIRS := '>';
const GLYPH_SWORD := '/';
const GLYPH_SHIELD := '(';
const GLYPH_SCROLL := ')';
const GLYPH_POTION := 'j';
const GLYPH_GOBELIN := 'g';
const GLYPH_ORC := 'o';

type screen_cell {
	glyph text,
	fg_color text,
	bg_color text
};

function screen_cell(glyph text, fg_color text, bg_color text) screen_cell begin
	return {glyph: glyph, fg_color: fg_color, bg_color: bg_color} as screen_cell;
end screen_cell;

const EMPTY_SCREEN_CELL := {glyph: GLYPH_SPACE, fg_color: ANSI_FG_WHITE, bg_color: ANSI_BG_BLACK} as screen_cell;
const FLOOR_SCREEN_CELL := {glyph: GLYPH_FLOOR, fg_color: ANSI_FG_BLUE, bg_color: ANSI_BG_BLACK} as screen_cell;
const WALL_SCREEN_CELL := {glyph: GLYPH_WALL, fg_color: ANSI_FG_GREEN, bg_color: ANSI_BG_BLACK} as screen_cell;
const DOWNSTAIRS_SCREEN_CELL := {glyph: GLYPH_DOWNSTAIRS, fg_color: ANSI_FG_YELLOW, bg_color: ANSI_BG_BLACK} as screen_cell;

#############
###
### ENTITIES
###

const ENTITY_ID_NONE := -1;

type viewrange {
	range integer,
	flags [[boolean]],
	dirty boolean
};

function viewrange(range integer) viewrange begin
	return {range: range, flags: [] as [[boolean]], dirty: true} as viewrange;
end viewrange;

type combatstat {
	max_hp integer,
	hp integer,
	defense integer,
	power integer,
	confused_turns integer
};

type equip_slot integer;

const EQUIP_SLOT_NONE    := -1 as equip_slot;
const EQUIP_SLOT_MELEE   := 0 as equip_slot;
const EQUIP_SLOT_DEFENSE := 1 as equip_slot;
const EQUIP_SLOT_COUNT   := 2;
const EQUIP_SLOT_NAMES   := ['Melee', 'Defense'];

type item {
	owner_id         integer,
	equippable_slot  equip_slot,
	equipped         boolean
};

type potion {
	hp integer
};

type scroll {
	range           integer,
	damage          integer,
	effect_radius   integer,
	confusion_turns integer
};

type combat_bonus {
	defense_bonus	integer,
	power_bonus		integer
};

type entity {
	name				text,
	is_active			boolean,
	position			null|point,
	display				null|screen_cell,
	viewrange			null|viewrange,
	combat_stat			null|combatstat,
	blocks_tile			boolean, 
	item				null|item,
	potion				null|potion,
	scroll				null|scroll,
	combat_bonus		null|combat_bonus		
};

function entity(name text, position point, display screen_cell) entity begin
	return {
		name:			name,
		is_active:		true,
		position:		position 				as null|point,
		display:		display					as null|screen_cell,
		viewrange:   	null					as null|viewrange,
		combat_stat:	null					as null|combatstat,
		blocks_tile:	false,
		item:			null					as null|item,
		potion:			null					as null|potion,
		scroll:			null					as null|scroll,
		combat_bonus:	null					as null|combat_bonus
	} as entity;
end entity;

function fighter_entity(e entity, viewrange integer, max_hp integer, defense integer, power integer) entity begin
	e.viewrange   := {range: viewrange, flags: [] as [[boolean]], dirty: true} as viewrange as null|viewrange;
	e.combat_stat := {max_hp: max_hp, hp: max_hp, defense: defense, power: power, confused_turns: 0} as combatstat as null|combatstat;
	e.blocks_tile := true;
	return e;
end fighter_entity;

function equippable_item_entity(e entity, slot equip_slot, defense_bonus integer, power_bonus integer) entity begin
	e.item := {owner_id: ENTITY_ID_NONE, equippable_slot: slot, equipped: false} as item as null|item;
	e.combat_bonus := {defense_bonus: defense_bonus, power_bonus: power_bonus} as combat_bonus as null|combat_bonus;
	return e;
end equippable_item_entity;

function potion_entity(e entity, hp integer) entity begin
	e.item   := {owner_id: ENTITY_ID_NONE, equippable_slot: EQUIP_SLOT_NONE, equipped: false} as item as null|item;
	e.potion := {hp: hp} as potion as null|potion;
	return e;
end potion_entity;

function scroll_entity(e entity, range integer, damage integer, effect_radius integer, confusion_turns integer) entity begin
	e.item   := {owner_id: ENTITY_ID_NONE, equippable_slot: EQUIP_SLOT_NONE, equipped: false} as item as null|item;
	e.scroll := {range: range, damage: damage, effect_radius: effect_radius, confusion_turns: confusion_turns} as scroll as null|scroll;
	return e;
end scroll_entity;

procedure print_visibility_flags(flags [[boolean]]) begin
	for y in 0 .. last_index(flags) loop
		var line := '';
		for x in 0 .. last_index(flags[y]) loop
			line := line || case when flags[y][x] then 'X' else '.' end;
		end loop;
		print(line);
	end loop;
end print_visibility_flags;

function in_viewrange(p point, entity entity) boolean begin
	kindof entity.viewrange when viewrange vr then
		kindof entity.position when point pos then
			if p.x >= pos.x - vr.range and
			   p.x <= pos.x + vr.range and
			   p.y >= pos.y - vr.range and
			   p.y <= pos.y + vr.range
			then
				var rel_x := vr.range + p.x - pos.x;
				var rel_y := vr.range + p.y - pos.y;
				if rel_y < 0 or rel_y >= length(vr.flags) or
				   rel_x < 0 or rel_x >= length(vr.flags[rel_y])
				then
					return false;
				end if;
				return vr.flags[rel_y][rel_x];
			end if;
			return false;
		end;
	end;
	return false;
end in_viewrange;

type equipment {
	backpack_items [integer],
	equip_items [integer]
};

function find_equipment(entities [entity], entity_id integer) equipment begin
	var backpack_items := [] as [integer];
	var equip_items := ENTITY_ID_NONE ** EQUIP_SLOT_COUNT;
	for i in 0 .. last_index(entities) loop
		var entity := entities[i];
		kindof entity.item when item item then
			if item.owner_id = entity_id then
				if item.equipped then
					equip_items[item.equippable_slot as integer] := i;
				else
					backpack_items := backpack_items || [i];
				end if;
			end if;
		end;
	end loop;
	return {backpack_items: backpack_items, equip_items: equip_items} as equipment;
end find_equipment;

#############
###
### GAME LOG
###

const MAX_MESSAGES := 20;

procedure add_message(ctx messages [text], msg text) begin
	if length(messages) = MAX_MESSAGES then
		messages := messages[1 .. MAX_MESSAGES - 1];
	end if;
	messages := messages || [msg];
end add_message;

########
###
### MAP
###

type tile_type integer;

const TILE_FLOOR 		:= 0 as tile_type;
const TILE_WALL  		:= 1 as tile_type;
const TILE_DOWNSTAIRS	:= 2 as tile_type;

type map {
	depth integer,
	tiles [[tile_type]],
	revealed_tiles [[boolean]],
	visible_tiles [[boolean]],
	rooms [rect],
	width integer,
	height integer,
	blocking_entities [[integer]],
	nonblocking_entities [[integer]]
};

function tiles_with_room(tiles [[tile_type]], room rect) [[tile_type]] begin
	for y in room.y1 + 1 .. room.y2  loop
        for x in room.x1 + 1 .. room.x2 loop
            tiles[y][x] := TILE_FLOOR;
        end loop;
    end loop;
    return tiles;
end tiles_with_room;

function tiles_with_horizontal_tunnel(tiles [[tile_type]], x1 integer, x2 integer, y integer) [[tile_type]] begin
    for x in min(x1, x2) .. max(x1, x2) loop
		tiles[y][x] := TILE_FLOOR;
    end loop;
    return tiles;
end tiles_with_horizontal_tunnel;

function tiles_with_vertical_tunnel(tiles [[tile_type]], y1 integer, y2 integer, x integer) [[tile_type]] begin
    for y in min(y1, y2) .. max(y1, y2) loop
		tiles[y][x] := TILE_FLOOR;
	end loop;
	return tiles;
end tiles_with_vertical_tunnel;

function make_map(depth integer, width integer, height integer) map begin
	var tiles := TILE_WALL ** width ** height;
	var revealed_tiles := false ** width ** height;
	var visible_tiles := false ** width ** height;
	var blocking_entities := ENTITY_ID_NONE ** width ** height;
	var nonblocking_entities := ENTITY_ID_NONE ** width ** height;
	var rooms := [] as [rect];
    const MAX_ROOMS := 20;
    const MIN_SIZE := 6;
    const MAX_SIZE := 14;
    for i in 0 .. MAX_ROOMS - 1 loop
        var w := random(MIN_SIZE, MAX_SIZE);
        var h := random(MIN_SIZE, MAX_SIZE);
        var x := random(1, width - w - 1) - 1;
        var y := random(1, height - h - 1) - 1;
        var new_room := make_rect(x, y, w, h);
        var ok := true;
        for j in 0 .. last_index(rooms) loop
            if intersect(new_room, rooms[j]) then
            	ok := false;
            end if;
        end loop;
        if ok then
            tiles := tiles_with_room(tiles, new_room);
            if length(rooms) > 0 then
				var new_center := center(new_room);
        		var prev_center := center(rooms[last_index(rooms)]);
				if random(0, 2) = 1 then
            		tiles := tiles_with_horizontal_tunnel(tiles, prev_center.x, new_center.x, prev_center.y);
            		tiles := tiles_with_vertical_tunnel(tiles, prev_center.y, new_center.y, new_center.x);
				else
            		tiles := tiles_with_vertical_tunnel(tiles, prev_center.y, new_center.y, prev_center.x);
            		tiles := tiles_with_horizontal_tunnel(tiles, prev_center.x, new_center.x, new_center.y);
            	end if;
			end if;
            rooms := rooms || [new_room];            
        end if;
    end loop;
    var downstairs_pos := center(rooms[last_index(rooms)]);
    tiles[downstairs_pos.y][downstairs_pos.x] := TILE_DOWNSTAIRS;
	return {
		depth: depth,
		tiles: tiles,
		revealed_tiles: revealed_tiles,
		visible_tiles: visible_tiles,
		rooms: rooms,
		width: width,
		height: height,
		blocking_entities: blocking_entities,
		nonblocking_entities: nonblocking_entities
	} as map;
end make_map;

function map_is_blocked(map map, pos point) boolean begin
	return map.tiles[pos.y][pos.x] = TILE_WALL or map.blocking_entities[pos.y][pos.x] >= 0;
end map_is_blocked;

function visible_tile_flags(tiles [[tile_type]], x integer, y integer, range integer) [[boolean]] begin
	var flags := false ** (2 * range + 1) ** (2 * range + 1);
	for dir in 1..4 loop
		for i in 0 .. range * 2 loop
			var border_x := case when dir = 1 or dir = 3 then i when dir = 2 then 2 * range else 0 end;
			var border_y := case when dir = 2 or dir = 4 then i when dir = 3 then 2 * range else 0 end;
			var ldc := line_dots_init(range, range, border_x, border_y);
			while ldc.again loop
				var d := line_dots_next(ctx ldc);
				flags[d.y][d.x] := true;
				exit when tiles[y - range + d.y][x - range + d.x] = TILE_WALL;
				if d.x > 0 then
					flags[d.y][d.x - 1] := true;
				end if;
				if d.x < 2 * range then
					flags[d.y][d.x + 1] := true;
				end if;
				if d.y > 0 then
					flags[d.y - 1][d.x] := true;
				end if;
				if d.y < 2 * range then
					flags[d.y + 1][d.x] := true;
				end if;
			end loop;
		end loop;
	end loop;
	return flags;
end visible_tile_flags;

###############
###
### PATHFINDER
###

generator map_neighbors(map map, p point) point begin
	if p.y > 0 then
		yield {x: p.x, y: p.y - 1} as point;
	end if;
	if p.x < map.width - 1 then
		yield {x: p.x + 1, y: p.y} as point;
	end if;
	if p.y < map.height - 1 then
		yield {x: p.x, y: p.y + 1} as point;
	end if;
	if p.x > 0 then
		yield {x: p.x - 1, y: p.y} as point;
	end if;
end map_neighbors;

function find_path(map map, start_pos point, end_pos point) [point] begin
	var frontier := [start_pos] as [point];
	var reached := false ** map.width ** map.height;
	var origins := {x: 0, y: 0} as point ** map.width ** map.height;
	while length(frontier) > 0 loop
		var new_frontier := [] as [point];
		for i in 0 .. last_index(frontier) loop
			for p in map_neighbors(map, frontier[i]) loop
				if p = end_pos then
					var path := [p];
					var origin := frontier[i];
					while origin <> start_pos loop
						path := [origin] || path;
						origin := origins[origin.y][origin.x];
					end loop;
					return path;
				elsif not reached[p.y][p.x] and not map_is_blocked(map, p) then
					reached[p.y][p.x] := true;
					origins[p.y][p.x] := frontier[i];
					new_frontier := new_frontier || [p];
				end if;
			end loop;
		end loop;
		frontier := new_frontier;
	end loop;
	return [] as [point];
end find_path;

############
###
### SPAWNER
###

function spawn_entity(ctx entities [entity], ctx map map, e entity) integer begin
	var entity_id := length(entities);
	entities := entities || [e];
	kindof e.position when point p then
		if e.blocks_tile then
			map.blocking_entities[p.y][p.x] := entity_id;
		else
			map.nonblocking_entities[p.y][p.x] := entity_id;
		end if;
	end;
	return entity_id;
end spawn_entity;

procedure spawn_entity(ctx entities [entity], ctx map map, e entity) begin
	var entity_id := spawn_entity(ctx entities, ctx map, e);
end spawn_entity;

procedure deactivate_entity(ctx entities [entity], ctx map map, entity_id integer) begin
	entities[entity_id].is_active := false;
	if entities[entity_id].blocks_tile then
		kindof entities[entity_id].position when point p then
			if map.blocking_entities[p.y][p.x] = entity_id then
				map.blocking_entities[p.y][p.x] := ENTITY_ID_NONE;
			end if;
		end;
	end if;
	kindof entities[entity_id].item when item item then
		item.owner_id := ENTITY_ID_NONE;
		entities[entity_id].item := item as null|item;
	end;
end deactivate_entity;

function spawn_player(ctx entities [entity], ctx map map) integer begin
	var first_room := map.rooms[0];
	var player_pos := {x: random(first_room.x1 + 1, first_room.x2), y: random(first_room.y1 + 1, first_room.y2)} as point;
	return spawn_entity(ctx entities, ctx map,
		fighter_entity(
			entity('Player', player_pos, screen_cell(GLYPH_PLAYER, ANSI_FG_BRIGHT_YELLOW, ANSI_BG_BLACK)),
			8, 100, 5, 10));
end spawn_player;

procedure spawn_gobelin(ctx entities [entity], ctx map map, spawn_point point) begin
	var viewrange := 4;
	var hp        := 20;
	var defense   := 2;
	var attack    := 10;
	spawn_entity(ctx entities, ctx map,
		fighter_entity(entity('Gobelin', spawn_point, screen_cell(GLYPH_GOBELIN, ANSI_FG_BRIGHT_RED, ANSI_BG_BLACK)),
		viewrange, hp, defense, attack));
end spawn_gobelin;

procedure spawn_orc(ctx entities [entity], ctx map map, spawn_point point) begin
	var viewrange := 5;
	var hp        := 25;
	var defense   := 4;
	var attack    := 12;
	spawn_entity(ctx entities, ctx map,
		fighter_entity(entity('Orc', spawn_point, screen_cell(GLYPH_ORC, ANSI_FG_BRIGHT_RED, ANSI_BG_BLACK)),
		viewrange, hp, defense, attack));
end spawn_orc;

procedure spawn_lightning_scroll(ctx entities [entity], ctx map map, spawn_point point) begin
	spawn_entity(ctx entities, ctx map, scroll_entity(
		entity('Lighning scroll', spawn_point, screen_cell(GLYPH_SCROLL, ANSI_FG_BRIGHT_CYAN, ANSI_BG_BLACK)),
		6, 15, 0, 0));
end spawn_lightning_scroll;

procedure spawn_fireball_scroll(ctx entities [entity], ctx map map, spawn_point point) begin
	spawn_entity(ctx entities, ctx map, scroll_entity(
		entity('Fireball scroll', spawn_point, screen_cell(GLYPH_SCROLL, ANSI_FG_BRIGHT_RED, ANSI_BG_BLACK)),
		6, 50, 2, 0));
end spawn_fireball_scroll;

procedure spawn_confusion_scroll(ctx entities [entity], ctx map map, spawn_point point) begin
	spawn_entity(ctx entities, ctx map, scroll_entity(
		entity('Confusion scroll', spawn_point, screen_cell(GLYPH_SCROLL, ANSI_FG_BRIGHT_MAGENTA, ANSI_BG_BLACK)),
		6, 0, 0, 4));
end spawn_confusion_scroll;

procedure spawn_sword(ctx entities [entity], ctx map map, spawn_point point) begin
	spawn_entity(ctx entities, ctx map, equippable_item_entity(
		entity('Sword', spawn_point, screen_cell(GLYPH_SWORD, ANSI_FG_BRIGHT_CYAN, ANSI_BG_BLACK)),
		EQUIP_SLOT_MELEE, 0, 2));
end spawn_sword;

procedure spawn_shield(ctx entities [entity], ctx map map, spawn_point point) begin
	spawn_entity(ctx entities, ctx map, equippable_item_entity(
		entity('Shield', spawn_point, screen_cell(GLYPH_SHIELD, ANSI_FG_BRIGHT_CYAN, ANSI_BG_BLACK)),
		EQUIP_SLOT_DEFENSE, 2, 0));
end spawn_shield;

procedure spawn_potion(ctx entities [entity], ctx map map, spawn_point point) begin
	spawn_entity(ctx entities, ctx map, potion_entity(
		entity('Potion', spawn_point, screen_cell(GLYPH_POTION, ANSI_FG_BRIGHT_MAGENTA, ANSI_BG_BLACK)),
		10));
end spawn_potion;

type spawn_id integer;
type spawn_weight {id spawn_id, weight integer};

function spawn_weight(id spawn_id, weight integer) spawn_weight begin
	return {id: id, weight: weight} as spawn_weight;
end spawn_weight;

function random_spawn_id(weights [spawn_weight]) spawn_id begin
	var total_weight := 0;
	for w in weights loop
		if w.weight > 0 then
			total_weight := total_weight + w.weight;
		end if;
	end loop;
	var dice := random(0, total_weight - 1);
	for i in 0 .. last_index(weights) - 1 loop
		if weights[i].weight > 0 then
			if dice < weights[i].weight then
				return weights[i].id;
			end if;
			dice := dice - weights[i].weight;
		end if;
	end loop;
	return weights[last_index(weights)].id;
end random_spawn_id;

const SPAWN_GOBELIN             := 0 as spawn_id;
const SPAWN_ORC                 := 1 as spawn_id;
const SPAWN_POTION              := 2 as spawn_id;
const SPAWN_FIREBALL_SCROLL     := 3 as spawn_id;
const SPAWN_CONFUSION_SCROLL    := 4 as spawn_id;
const SPAWN_LIGHTNING_SCROLL    := 5 as spawn_id;
const SPAWN_SWORD               := 6 as spawn_id;
const SPAWN_SHIELD              := 7 as spawn_id;

function spawn_weigths(depth integer) [spawn_weight] begin
	return [
		spawn_weight(SPAWN_GOBELIN,          10),
		spawn_weight(SPAWN_ORC,    			  1 + depth),
		spawn_weight(SPAWN_POTION,            7),
		spawn_weight(SPAWN_FIREBALL_SCROLL,   2 + depth),
		spawn_weight(SPAWN_CONFUSION_SCROLL,  2 + depth),
		spawn_weight(SPAWN_LIGHTNING_SCROLL,  4),
		spawn_weight(SPAWN_SWORD,             2),
		spawn_weight(SPAWN_SHIELD,            2)
	];
end spawn_weigths;

procedure spawn_random_entity(ctx entities [entity], ctx map map, spawn_point point, weights [spawn_weight]) begin
	var id := random_spawn_id(weights);
	if    id = SPAWN_GOBELIN          then spawn_gobelin(ctx entities, ctx map, spawn_point);
	elsif id = SPAWN_ORC              then spawn_orc(ctx entities, ctx map, spawn_point);
	elsif id = SPAWN_POTION           then spawn_potion(ctx entities, ctx map, spawn_point);
	elsif id = SPAWN_FIREBALL_SCROLL  then spawn_fireball_scroll(ctx entities, ctx map, spawn_point);
	elsif id = SPAWN_CONFUSION_SCROLL then spawn_confusion_scroll(ctx entities, ctx map, spawn_point);
	elsif id = SPAWN_LIGHTNING_SCROLL then spawn_lightning_scroll(ctx entities, ctx map, spawn_point);
	elsif id = SPAWN_SWORD            then spawn_sword(ctx entities, ctx map, spawn_point);
	elsif id = SPAWN_SHIELD           then spawn_shield(ctx entities, ctx map, spawn_point);
	end if;
end spawn_random_entity;

procedure populate_room(ctx entities [entity], ctx map map, room rect, weights [spawn_weight]) begin
	var spawn_points := [] as [point];
	var spawn_num := random(1, 4) + map.depth - 2;
	for i in 1 .. spawn_num loop
		var spawn_point := {x: random(room.x1 + 1, room.x2), y: random(room.y1 + 1, room.y2)} as point;
		if not point_in_array(spawn_point, spawn_points) then
			spawn_random_entity(ctx entities, ctx map, spawn_point, weights);
			spawn_points := spawn_points || [spawn_point];
		end if;
	end loop;
end populate_room;

procedure populate_map(ctx entities [entity], ctx map map) begin
	var weights := spawn_weigths(map.depth);
	for i in 1 .. last_index(map.rooms) loop
		populate_room(ctx entities, ctx map, map.rooms[i], weights);
	end loop;
end populate_map;

############
###
### DISPLAY
###

const CHAR_SPACE := char_at(' ', 0);

procedure render(ctx screen [[screen_cell]], entities [entity], map map) begin
	for y in 0 .. SCREEN_HEIGHT - 1 loop
		for x in 0 .. SCREEN_WIDTH - 1 loop
			if map.visible_tiles[y][x] or map.revealed_tiles[y][x] then
				screen[y][x] := case map.tiles[y][x]
					when TILE_FLOOR      then FLOOR_SCREEN_CELL
					when TILE_WALL       then WALL_SCREEN_CELL
					when TILE_DOWNSTAIRS then DOWNSTAIRS_SCREEN_CELL
					else EMPTY_SCREEN_CELL
				end;
				if map.visible_tiles[y][x] then
					var entity_id := map.blocking_entities[y][x];
					if entity_id < 0 or entities[entity_id].display = null as null|screen_cell then
						entity_id := map.nonblocking_entities[y][x];
					end if;
					if entity_id >= 0 then
						kindof entities[entity_id].display when screen_cell d then
							screen[y][x].glyph := d.glyph;
							screen[y][x].fg_color := d.fg_color;
							screen[y][x].bg_color := d.bg_color;
						end;
					end if;
				else
					screen[y][x].fg_color := ANSI_FG_WHITE;
				end if;
			else
				screen[y][x] := EMPTY_SCREEN_CELL;
			end if;
		end loop;
	end loop;	
end render;

function screen_line_to_text(line [screen_cell]) text begin
	var t := ansi_color(ANSI_FG_WHITE, ANSI_BG_BLACK);
	var last_fg := ANSI_FG_WHITE;
	var last_bg := ANSI_BG_BLACK;
	for i in 0 .. last_index(line) loop
		var r := line[i];
		if r.fg_color <> last_fg then
			if r.bg_color <> last_bg then
				t := t || ANSI_CSI || r.fg_color || ANSI_SGR_SEP || r.bg_color || ANSI_SGR_TERM;
				last_fg := r.fg_color;
				last_bg := r.bg_color;
			else
				t := t || ANSI_CSI || r.fg_color || ANSI_SGR_TERM;
				last_fg := r.fg_color;
			end if;
		elsif r.bg_color <> last_bg then
			t := t || ANSI_CSI || r.bg_color || ANSI_SGR_TERM;
			last_bg := r.bg_color;
		end if;
		t := t || r.glyph;
	end loop;
	return t;
end screen_line_to_text;

procedure display(screen [[screen_cell]], depth integer, player entity, messages [text]) begin
	for i in 0 .. last_index(screen) loop
		if i = 0 then
			print(ANSI_HIDE_CURSOR || ANSI_CLEAR_TERMINAL || screen_line_to_text(screen[i]) || ANSI_CR);			
		else
			print(screen_line_to_text(screen[i]) || ANSI_CR);
		end if;
	end loop;
	kindof player.combat_stat when combatstat cs then
		var status_line := 'Depth: ' || text(depth) || '    Health: ' || text(cs.hp) || '/' || text(cs.max_hp);
		status_line := status_line || text(CHAR_SPACE ** (SCREEN_WIDTH - length(status_line)));
		write(ansi_color(ANSI_FG_YELLOW, ANSI_BG_BLUE) || status_line || ansi_color(ANSI_FG_WHITE, ANSI_BG_BLACK));
	end;
	for i in max(0, length(messages) - 3) .. last_index(messages) loop
		write(ANSI_CR || ANSI_LF || messages[i]);
	end loop;
end display;

###############
###
### GAME LOGIC
###

procedure move_entity(ctx entities [entity], ctx map map, entity_id integer, pos point) begin
	kindof entities[entity_id].position when point old_pos then
		if not map_is_blocked(map, pos) then
			if map.blocking_entities[old_pos.y][old_pos.x] = entity_id then
				map.blocking_entities[old_pos.y][old_pos.x] := ENTITY_ID_NONE;
			end if;
			entities[entity_id].position := pos as null|point;
			if entities[entity_id].blocks_tile then
				map.blocking_entities[pos.y][pos.x] := entity_id;
			end if;
			kindof entities[entity_id].viewrange when viewrange vr then
				vr.dirty := true;
				entities[entity_id].viewrange := vr as null|viewrange;
			end;
		end if;
	end;
end move_entity;

procedure attack_entity(ctx entities [entity], ctx map map, ctx messages [text], attacker_id integer, target_id integer) begin
	var attacker := entities[attacker_id];
	var target := entities[target_id];
	kindof attacker.combat_stat when combatstat attacker_stat then
		kindof target.combat_stat when combatstat target_stat then
			var power_bonus := 0;
			var defense_bonus := 0;
			for i in 0 .. last_index(entities) loop
				kindof entities[i].item when item item then
					if item.owner_id = attacker_id then
						kindof entities[i].combat_bonus when combat_bonus cb then
							power_bonus := power_bonus + cb.power_bonus;
						end;
					elsif item.owner_id = target_id then
						kindof entities[i].combat_bonus when combat_bonus cb then
							defense_bonus := defense_bonus + cb.defense_bonus;
						end;
					end if;
				end;
			end loop;
			var damage := attacker_stat.power + power_bonus - target_stat.defense - defense_bonus;
			if damage < 0 then
				damage := 0;
			end if;
			target_stat.hp := target_stat.hp - damage;
			entities[target_id].combat_stat := target_stat as null|combatstat;
			add_message(ctx messages, attacker.name || ' dealt ' || text(damage) || ' damage to ' || target.name);
			if target_stat.hp <= 0 then
				deactivate_entity(ctx entities, ctx map, target_id);
			end if;
		end;
	end;
end attack_entity;

procedure move_player(ctx entities [entity], ctx map map, ctx messages [text], player_id integer, dx integer, dy integer) begin
	kindof entities[player_id].position when point p then
		p.x := p.x + dx;
		p.y := p.y + dy;
		var target_entity_id := map.blocking_entities[p.y][p.x];
		if target_entity_id <> ENTITY_ID_NONE then
			attack_entity(ctx entities, ctx map, ctx messages, player_id, target_entity_id);
		else
			move_entity(ctx entities, ctx map, player_id, p);
		end if;
	end;
end move_player;

procedure pickup_item(ctx entities [entity], ctx messages [text], ctx map map, player_id integer) begin
	kindof entities[player_id].position when point p then
		var picked_id := map.nonblocking_entities[p.y][p.x];
		if picked_id = ENTITY_ID_NONE then
			add_message(ctx messages, 'Nothing to pick');
		else
			kindof entities[picked_id].item
			when item item then
				map.nonblocking_entities[p.y][p.x] := ENTITY_ID_NONE;
				item.owner_id := player_id;
				entities[picked_id].item := item as null|item;
				entities[picked_id].position := null as null|point;
				map.nonblocking_entities[p.y][p.x] := ENTITY_ID_NONE;
				add_message(ctx messages, entities[player_id].name || ' picked ' || entities[picked_id].name);
			else
				add_message(ctx messages, 'You can''t pick ' || entities[picked_id].name);
			end;
		end if;
	end;	
end pickup_item;

procedure equip_item(ctx entities [entity], item_id integer) begin
	kindof entities[item_id].item when item item then
		var owner_id := item.owner_id;
		if owner_id = ENTITY_ID_NONE then
			return;
		end if;
		if item.equippable_slot = EQUIP_SLOT_NONE then
			return;
		end if;
		var equipment := find_equipment(entities, owner_id);
		var already_equip_item_id := equipment.equip_items[item.equippable_slot as integer];
		if already_equip_item_id <> ENTITY_ID_NONE then
			kindof entities[already_equip_item_id].item when item ei then
				ei.equipped := false;
				entities[already_equip_item_id].item := ei as null|item;
			end;
		end if;
		item.equipped := true;
		entities[item_id].item := item as null|item;
	end;
end equip_item;

procedure update_viewranges(ctx entities [entity], ctx map map, player_id integer, ctx visibe_tile_flags_time integer) begin
	for i in 0 .. last_index(entities) loop
		const entity := entities[i];
		if entity.is_active then
			kindof entity.viewrange when viewrange r then
				if r.dirty then
					kindof entity.position when point p then
						var t1 := now();
						r.flags := visible_tile_flags(map.tiles, p.x, p.y, r.range);
						visibe_tile_flags_time := visibe_tile_flags_time + now() - t1;
						r.dirty := false;
						entities[i].viewrange := r as null|viewrange;
						if i = player_id then
							for y in 0 .. map.height - 1 loop
								for x in 0 .. map.width - 1 loop
									map.visible_tiles[y][x] := false;
								end loop;
							end loop;
							for y in 0 .. 2 * r.range loop
								for x in 0 .. 2 * r.range loop
									var map_y := p.y + y - r.range;
									var map_x := p.x + x - r.range;
									if r.flags[y][x] and map_x >= 0 and map_x < map.width and map_y >= 0 and map_y < map.height then
										map.revealed_tiles[map_y][map_x] := true;
										map.visible_tiles[map_y][map_x] := true;
									end if;
								end loop;
							end loop; 
						end if;
					end;
				end if;
			end;
		end if;
	end loop;
end update_viewranges;

procedure animate_fighters(ctx entities [entity], ctx map map, ctx messages [text], player_id integer) begin
	for i in 0 .. last_index(entities) loop
		if i <> player_id then
			const entity := entities[i];
			if entity.is_active then
				kindof entity.combat_stat when combatstat cs then
					if cs.confused_turns > 0 then
						cs.confused_turns := cs.confused_turns - 1;
						entities[i].combat_stat := cs as null|combatstat;
					else
						kindof entity.position when point p then
							kindof entities[player_id].position when point player_pos then
								if entities[player_id].is_active and in_viewrange(player_pos, entities[i]) then
									var path := find_path(map, p, player_pos);
									if length(path) > 0 then
										var next_pos := path[0];
										if next_pos = player_pos then
											attack_entity(ctx entities, ctx map, ctx messages, i, player_id);
										elsif not map_is_blocked(map, next_pos) then
											move_entity(ctx entities, ctx map, i, next_pos);
										end if;
									else
										add_message(ctx messages, entity.name || ': come here if you''re a man');
									end if;
								end if;
							end;
						end;
					end if;
				end;
			end if;
		end if;
	end loop;	
end animate_fighters;

procedure heal_entity(ctx entities [entity], entity_id integer, hp integer) begin
	kindof entities[entity_id].combat_stat when combatstat cs then
		cs.hp := cs.hp + hp;
		if cs.hp > cs.max_hp then
			cs.hp := cs.max_hp;
		end if;
		entities[entity_id].combat_stat := cs as null|combatstat;
	end;
end heal_entity;

procedure entity_use_item(
	ctx screen		any,
	ctx entities	[entity],
	ctx map			map,
	ctx messages	[text],
	entity_id		integer,
	item_id			integer
)
begin
	kindof entities[item_id].potion when potion p then
		heal_entity(ctx entities, entity_id, p.hp);
		deactivate_entity(ctx entities, ctx map, item_id);
		add_message(ctx messages, entities[entity_id].name || ' used ' || entities[item_id].name);
	end;
	kindof entities[item_id].scroll when scroll s then
		var target_pos := choose_target_position(ctx screen, entities, map, messages, entity_id, s.range);
		kindof target_pos when point p then
			add_message(ctx messages, entities[entity_id].name || ' used ' || entities[item_id].name);
			for y in p.y - s.effect_radius .. p.y + s.effect_radius loop
				for x in p.x - s.effect_radius .. p.x + s.effect_radius loop
					var target_id := map.blocking_entities[y][x];
					if target_id <> ENTITY_ID_NONE then
						kindof entities[target_id].combat_stat when combatstat cs then
							if s.damage > 0 then
								cs.hp := cs.hp - s.damage;
								add_message(
									ctx messages,
									entities[entity_id].name || ' dealt ' || text(s.damage) || ' damage to ' || entities[target_id].name
								);
							end if;
							if s.confusion_turns > 0 and cs.confused_turns < s.confusion_turns then
								cs.confused_turns := s.confusion_turns;
								add_message(
									ctx messages,
									entities[entity_id].name || ' confused ' || entities[target_id].name ||
										' for ' || text(s.confusion_turns) || ' turns' 
								);
							end if;
							entities[target_id].combat_stat := cs as null|combatstat;
							if cs.hp <= 0 then
								deactivate_entity(ctx entities, ctx map, target_id);
							end if;
						end;
					end if;
				end loop;
			end loop;
			deactivate_entity(ctx entities, ctx map, item_id);
		end;
	end;
end entity_use_item;

procedure go_next_level(ctx entities [entity], ctx map map, ctx player_id integer, ctx messages [text]) begin
	var can_descend := false;
	kindof entities[player_id].position when point p then
		if map.tiles[p.y][p.x] = TILE_DOWNSTAIRS then
			can_descend := true;
		end if;
	end;
	if not can_descend then
		add_message(ctx messages, 'You cannot descend to the new level here');
		return;
	end if;
	var new_player_id := 0;
	var new_entities := [] as [entity];
	for i in 0 .. last_index(entities) loop
		if i = player_id then
			new_entities := new_entities || [entities[i]];
			new_player_id := last_index(new_entities);
		elsif entities[i].is_active then
			kindof entities[i].item when item itm then
				if itm.owner_id = player_id then
					new_entities := new_entities || [entities[i]];
				end if;
			end;
		end if;
	end loop;
	player_id := new_player_id;
	entities := new_entities;
	map := make_map(map.depth + 1, SCREEN_WIDTH, SCREEN_HEIGHT);
	var first_room := map.rooms[0];
	var player_pos := {x: random(first_room.x1 + 1, first_room.x2), y: random(first_room.y1 + 1, first_room.y2)} as point;
	map.blocking_entities[player_pos.y][player_pos.x] := player_id;
	entities[player_id].position := player_pos as null|point;
	kindof entities[player_id].viewrange when viewrange vr then
		vr.dirty := true;
		entities[player_id].viewrange := vr as null|viewrange;
	end;
	populate_map(ctx entities, ctx map);
	add_message(ctx messages, 'You descend to the new level');
end go_next_level;

#####################
###
### GAME INPUT LOOPS
###

const IN_CHAR_UP := char_at('i', 0);
const IN_CHAR_DOWN := char_at('k', 0);
const IN_CHAR_LEFT := char_at('j', 0);
const IN_CHAR_RIGHT := char_at('l', 0);
const IN_CHAR_QUIT := char_at('x', 0);
const IN_CHAR_UPRIGHT := char_at('o', 0);
const IN_CHAR_UPLEFT := char_at('u', 0);
const IN_CHAR_DOWNRIGHT := char_at(';', 0);
const IN_CHAR_DOWNLEFT := char_at(',', 0);
const IN_CHAR_PICKUP := char_at(' ', 0);
const IN_CHAR_INVENTORY := char_at('y', 0);
const IN_CHAR_DOWNSTAIRS := char_at('n', 0);
const IN_CHAR_SKIPTURN := char_at('p', 0);

function choose_target_position(ctx screen [[screen_cell]], entities[entity], map map, messages [text], player_id integer, range integer) null|point begin
	kindof entities[player_id].position when point pos then
		var target_pos := pos;
		while true loop
			render(ctx screen, entities, map);
			screen[target_pos.y][target_pos.x].bg_color := ANSI_BG_CYAN;
			display(screen, map.depth, entities[player_id], messages);
			var new_pos := target_pos;
			var input := get_char();
			if input = IN_CHAR_UP then
				new_pos.y := new_pos.y - 1;
			elsif input = IN_CHAR_DOWN then
				new_pos.y := new_pos.y + 1;
			elsif input = IN_CHAR_LEFT then
				new_pos.x := new_pos.x - 1;
			elsif input = IN_CHAR_RIGHT then
				new_pos.x := new_pos.x + 1;
			elsif input = IN_CHAR_UPRIGHT then
				new_pos.y := new_pos.y - 1;
				new_pos.x := new_pos.x + 1;
			elsif input = IN_CHAR_UPLEFT then
				new_pos.y := new_pos.y - 1;
				new_pos.x := new_pos.x - 1;
			elsif input = IN_CHAR_DOWNRIGHT then
				new_pos.y := new_pos.y + 1;
				new_pos.x := new_pos.x + 1;
			elsif input = IN_CHAR_DOWNLEFT then
				new_pos.y := new_pos.y + 1;
				new_pos.x := new_pos.x - 1;
			elsif input = IN_CHAR_PICKUP then
				return target_pos as null|point;
			elsif input = IN_CHAR_QUIT then
				exit;
			end if;
			if new_pos.x >= pos.x - range and new_pos.x <= pos.x + range and
			   new_pos.y >= pos.y - range and new_pos.y <= pos.y + range and 
			   in_viewrange(new_pos, entities[player_id])
			then
				target_pos := new_pos;
			end if;
		end loop;
	end;
	return null as null|point;
end choose_target_position;

function choose_inventory_item(ctx entities [entity], player_id integer) integer begin
	while true loop
		var equipment := find_equipment(entities, player_id);
		print(ANSI_HIDE_CURSOR || ANSI_CLEAR_TERMINAL || 'Backpack (' || text(length(equipment.backpack_items)) || ' items):' || ANSI_CR);			
		for i in 0 .. last_index(equipment.backpack_items) loop
			print(text(i + 1) || ': ' || entities[equipment.backpack_items[i]].name || ANSI_CR);
		end loop;
		print('');
		print('Equipped:');
		for i in 0 .. EQUIP_SLOT_COUNT - 1 loop
			var slot_name := EQUIP_SLOT_NAMES[i];
			var item_name := case equipment.equip_items[i]
				when ENTITY_ID_NONE then 'none'
				else entities[equipment.equip_items[i]].name
			end;
			print(slot_name || ': ' || item_name);
		end loop;
		print('');
		print('x: Exit inventory' || ANSI_CR);
		var input := get_char();
		exit when input = IN_CHAR_QUIT;
		var item_num := input as integer - char_code('1', 0);
		if item_num >= 0 and item_num < 9 and item_num < length(equipment.backpack_items) then
			var item_id := equipment.backpack_items[item_num];
			kindof entities[item_id].item when item item then
				if item.equippable_slot <> EQUIP_SLOT_NONE then
					equip_item(ctx entities, item_id);
					item_id := ENTITY_ID_NONE;
				end if;
			end;
			if item_id <> ENTITY_ID_NONE then
				return item_id;
			end if;
		end if;
	end loop;
	return ENTITY_ID_NONE;
end choose_inventory_item;

procedure game_over_loop() begin
	print(ANSI_HIDE_CURSOR || ANSI_CLEAR_TERMINAL || 'You died, game over.' || ANSI_CR);			
	var input := get_char();
end game_over_loop;

procedure main_loop() begin
	var entities := [] as [entity];
	var screen := EMPTY_SCREEN_CELL ** SCREEN_WIDTH ** SCREEN_HEIGHT;
	var messages := [] as [text];
	var map := make_map(1, SCREEN_WIDTH, SCREEN_HEIGHT);
	var player_id := spawn_player(ctx entities, ctx map);
	populate_map(ctx entities, ctx map);
	var frame_count := 0;
	var viewrange_tick_time := 0;
	var visibe_tile_flags_time := 0;
	var monster_tick_time := 0;
	var render_time := 0;
	var display_time := 0;
	var exit_main_loop := false;
	while not exit_main_loop loop
		frame_count := frame_count + 1;
		var t1 := now();
		update_viewranges(ctx entities, ctx map, player_id, ctx visibe_tile_flags_time);
		var t2 := now();
		animate_fighters(ctx entities, ctx map, ctx messages, player_id);
		var t3 := now();
		if not entities[player_id].is_active then
			game_over_loop();
			exit;
		end if;
		render(ctx screen, entities, map);
		var t4 := now();
		display(screen, map.depth, entities[player_id], messages);
		var t5 := now();
		viewrange_tick_time := viewrange_tick_time + t2 - t1;
		monster_tick_time := monster_tick_time + t3 - t2;
		render_time := render_time + t4 - t3;
		display_time := display_time + t5 - t4; 
		var exit_input_loop := false;
		while not exit_input_loop loop
			exit_input_loop := true;
			var input := get_char();
			if input = IN_CHAR_UP then
				move_player(ctx entities, ctx map, ctx messages, player_id, 0, -1);
			elsif input = IN_CHAR_DOWN then
				move_player(ctx entities, ctx map, ctx messages, player_id, 0, 1);
			elsif input = IN_CHAR_LEFT then
				move_player(ctx entities, ctx map, ctx messages, player_id, -1, 0);
			elsif input = IN_CHAR_RIGHT then
				move_player(ctx entities, ctx map, ctx messages, player_id, 1, 0);
			elsif input = IN_CHAR_UPRIGHT then
				move_player(ctx entities, ctx map, ctx messages, player_id, 1, -1);
			elsif input = IN_CHAR_UPLEFT then
				move_player(ctx entities, ctx map, ctx messages, player_id, -1, -1);
			elsif input = IN_CHAR_DOWNRIGHT then
				move_player(ctx entities, ctx map, ctx messages, player_id, 1, 1);
			elsif input = IN_CHAR_DOWNLEFT then
				move_player(ctx entities, ctx map, ctx messages, player_id, -1, 1);
			elsif input = IN_CHAR_PICKUP then
				pickup_item(ctx entities, ctx messages, ctx map, player_id);
			elsif input = IN_CHAR_INVENTORY then
				var item_id := choose_inventory_item(ctx entities, player_id);
				if item_id <> ENTITY_ID_NONE then
					entity_use_item(ctx screen, ctx entities, ctx map, ctx messages, player_id, item_id);
				end if;
			elsif input = IN_CHAR_DOWNSTAIRS then
				go_next_level(ctx entities, ctx map, ctx player_id, ctx messages);
			elsif input = IN_CHAR_SKIPTURN then
				add_message(ctx messages, 'Player skip his turn');
				heal_entity(ctx entities, player_id, 1);
			elsif input = IN_CHAR_QUIT then
				exit_main_loop := true;
			else
				add_message(ctx messages, 'Unknown input ' || text(input));
				display(screen, map.depth, entities[player_id], messages);
				exit_input_loop := false;
			end if;
		end loop;
	end loop;
	write(ANSI_CLEAR_TERMINAL || ANSI_SHOW_CURSOR || ANSI_RESET_COLOR);
	print('frame_count         : ' || text(frame_count));
	print('viewrange_tick_time : ' || text(viewrange_tick_time / frame_count));
	print('visibe_tile_flags_time : ' || text(visibe_tile_flags_time / frame_count));
	print('monster_tick_time   : ' || text(monster_tick_time / frame_count));
	print('render_time         : ' || text(render_time / frame_count));
	print('display_time        : ' || text(display_time / frame_count));
end main_loop;

main_loop();



