<!DOCTYPE html>
<meta charset="UTF-8">
<html>
<head>
<title>IR Test</title>
<script src="PlwOpcodes.js"></script>
<script src="PlwCodeBlock.js"></script>
<script src="PlwIR.js"></script>
</head>
<body>
<textarea id="output" cols="100" rows="25"></textarea>
<script>

function hexDumpToByteArray(dump) {	
	let parsedDump = [];
	let lines = dump.split("\n");
	for (let i = 0; i < lines.length; i++) {
		let line = lines[i].trim();
		let colonPos = line.indexOf(":");
		if (colonPos !== -1) {
			line = line.substring(colonPos + 1);
			let words = line.split(" ");
			for (let j = 0; j < words.length; j++) {
				let word = words[j].trim();
				if (word.length >= 2) {
					parsedDump[parsedDump.length] = parseInt(word.substring(0, 2), 16);
				}
				if (word.length >= 4) {
					parsedDump[parsedDump.length] = parseInt(word.substring(2, 4), 16);
				}
			}
		}
	}
	return new Uint8Array(parsedDump);
}

const PLW_RT_MODULE = hexDumpToByteArray(`
0000000: 0061 736d 0100 0000 0113 0460 017f 017f 
0000010: 6000 017f 6002 7f7f 0060 017f 0003 1514 
0000020: 0001 0002 0002 0002 0002 0003 0300 0003 
0000030: 0000 0003 0503 0100 0106 0b02 7f01 4108 
0000040: 0b7f 0141 080b 0784 010a 066d 656d 6f72 
0000050: 7902 0012 4d45 4d5f 6669 7273 7446 7265 
0000060: 6542 6c6f 636b 0300 0d4d 454d 5f6c 6173 
0000070: 7442 6c6f 636b 0301 084d 454d 5f69 6e69 
0000080: 7400 0c09 4d45 4d5f 616c 6c6f 6300 0e08 
0000090: 4d45 4d5f 6672 6565 000f 0a52 4546 5f63 
00000a0: 7265 6174 6500 1009 5245 465f 696e 6352 
00000b0: 6300 1109 5245 465f 6465 6352 6300 120b 
00000c0: 5245 465f 6465 7374 726f 7900 130a da06 
00000d0: 140a 0041 0720 006a 4178 710b 0400 4110 
00000e0: 0b07 0020 0028 0200 0b09 0020 0020 0136 
00000f0: 0200 0b07 0020 0028 0204 0b09 0020 0020 
0000100: 0136 0204 0b0a 0020 0041 086a 2802 000b 
0000110: 0c00 2000 4108 6a20 0136 0200 0b0a 0020 
0000120: 0041 0c6a 2802 000b 0c00 2000 410c 6a20 
0000130: 0136 0200 0b09 0020 0010 0641 7f46 0b08 
0000140: 0020 0041 7f10 070b 2a00 2000 2400 2000 
0000150: 2401 2300 3f00 4180 8004 6c23 006b 1003 
0000160: 2300 4100 1005 2300 4100 1007 2300 4100 
0000170: 1009 0b2e 0102 7f20 0010 016a 2101 2300 
0000180: 2102 0240 2002 4504 400c 010b 2001 2002 
0000190: 1002 4d04 400c 010b 2002 1008 2102 0b20 
00001a0: 020b d101 0107 7f20 0045 0440 4100 0f0b 
00001b0: 2000 1000 2100 2000 100d 2101 2001 4504 
00001c0: 4000 0b20 0110 0221 0220 0110 0621 0320 
00001d0: 0110 0821 0420 0110 0b20 0220 0010 0141 
00001e0: 046c 6a4a 0440 2001 2000 1001 6a10 0320 
00001f0: 0120 0110 026a 2105 2005 2002 2001 1002 
0000200: 6b10 0320 0520 0110 0520 0520 0310 0720 
0000210: 0520 0410 0920 0345 0440 2005 2400 0520 
0000220: 0320 0510 090b 2004 4100 4704 4020 0420 
0000230: 0510 070b 2001 2301 4604 4020 0524 0105 
0000240: 2001 2002 6a21 0620 0620 0510 050b 0520 
0000250: 0345 0440 2004 2400 0520 0320 0410 090b 
0000260: 2004 4100 4a04 4020 0420 0310 070b 0b20 
0000270: 0110 016a 0bd5 0201 0a7f 2000 1001 6b21 
0000280: 0120 0110 0221 0220 0110 0421 0341 0021 
0000290: 0420 0341 0047 0440 2003 100a 4504 4041 
00002a0: 0121 040b 0b20 0120 026a 2105 4100 2106 
00002b0: 2005 4100 4704 4020 0510 0a45 0440 4101 
00002c0: 2106 0b0b 2004 0440 2006 0440 2005 1002 
00002d0: 2107 2005 2007 6a21 0820 0320 0310 0220 
00002e0: 0220 076a 6a10 0320 0523 0146 0440 2003 
00002f0: 2401 0520 0820 0310 050b 2005 1006 2109 
0000300: 2005 1008 210a 2009 4504 4020 0a24 0005 
0000310: 2009 200a 1009 0b20 0a41 0047 0440 200a 
0000320: 2009 1007 0b05 2003 2003 1002 2002 6a10 
0000330: 0320 0123 0146 0440 2003 2401 0520 0520 
0000340: 0310 050b 0b05 2006 0440 2005 1002 2107 
0000350: 2005 2007 6a21 0820 0510 0621 0920 0510 
0000360: 0821 0a20 0120 0220 076a 1003 2001 2009 
0000370: 1007 2001 200a 1009 2005 2301 4604 4020 
0000380: 0124 0105 2008 2001 1005 0b20 0945 0440 
0000390: 2001 2400 0520 0920 0110 090b 200a 4100 
00003a0: 4704 4020 0a20 0110 070b 0520 0141 0010 
00003b0: 0720 0123 0010 0923 0041 0047 0440 2300 
00003c0: 2001 1007 0b20 0124 000b 0b0b 1901 017f 
00003d0: 2000 4104 6a10 0e21 0120 0141 0136 0200 
00003e0: 2001 4104 6a0b 1a01 017f 2000 4104 6b21 
00003f0: 0120 0120 0128 0200 4101 6a36 0200 2000 
0000400: 0b1e 0102 7f20 0041 046b 2101 2001 2802 
0000410: 0041 016b 2102 2001 2002 3602 0020 020b 
0000420: 0900 2000 4104 6b10 0f0b
`);

function printLog(text) {
	document.getElementById("output").value += "" + text + "\n";
}

function printMemDump(rtModuleInstance) {
	let mem = new Uint32Array(rtModuleInstance.exports.memory.buffer);
	let firstFreeBlock = rtModuleInstance.exports.MEM_firstFreeBlock;
	let lastBlock = rtModuleInstance.exports.MEM_lastBlock;
	
	printLog("=== DUMP ==========================================");
	printLog("");
	printLog("First free block: " + firstFreeBlock);
	printLog("Last block: " + lastBlock);
	printLog("");
	let b = 2;
	let totalBlockSize = 0;
	while (b <= lastBlock) {
		let size = mem[b];
		let prev = mem[b + 1];
		let prevFree = mem[b + 2];
		let nextFree = mem[b + 3];
		totalBlockSize += size;
		if (prevFree === 0xFFFFFFFF) {
			printLog("" + (b << 2) + ": used: size " + size + ", prev " + prev +
					", ptr " + ((b << 2) + 16));
		} else {
			printLog("" + (b << 2) + ": free: size " + size + ", prev " + prev +
					", prevFree " + prevFree + ", nextFree " + nextFree);
		}
		b += size >> 2;
	}
	printLog("");
	printLog("Total Block Size: " + totalBlockSize);
	printLog("");
}



let testIRModule = new PlwIRModule("test");

const IRF_PrintI64 = testIRModule.addFunction(new PlwIRFunction("printI64", "stdlib", 1, [], [PLW_IR_TYPE_I64], null));
const IRF_PrintI32 = testIRModule.addFunction(new PlwIRFunction("printI32", "stdlib", 1, [], [PLW_IR_TYPE_I32], null));

const IRT_Str = testIRModule.addRefType(new PlwIRRefType([PLW_IR_TYPE_I32], 0));
const IRT_Point = testIRModule.addRefType(new PlwIRRefType([IRT_Str, PLW_IR_TYPE_I64, PLW_IR_TYPE_I64], 1));

const IRF_AddPoints = testIRModule.addFunction(new PlwIRFunction("add_points", null, 2,
	[IRT_Point],
	[IRT_Point, IRT_Point, IRT_Point],
	PlwIR.block([
		PlwIR.setLocal([2], PlwIR.createRef(IRT_Point)),
		PlwIR.storeI64(2, 0, PlwIR.i32(0),
			PlwIR.binOp(PLW_IR_OP_I64_ADD,
				PlwIR.loadI64(0, 0, PlwIR.i32(0)),
				PlwIR.loadI64(1, 0, PlwIR.i32(0)))),
		PlwIR.storeI64(2, 1, PlwIR.i32(0),
			PlwIR.binOp(PLW_IR_OP_I64_ADD,
				PlwIR.loadI64(0, 1, PlwIR.i32(0)),
				PlwIR.loadI64(1, 1, PlwIR.i32(0)))),		
		PlwIR.decRefCount(0),
		PlwIR.decRefCount(1),
		PlwIR.ret([PlwIR.local(2)])
	])
));

const IRF_TestAddPoints = testIRModule.addFunction(new PlwIRFunction("test_add_points", null, 0,
	[],
	[IRT_Point, IRT_Point, IRT_Point],
	PlwIR.block([
		PlwIR.setLocal([0], PlwIR.createRef(IRT_Point)),
		PlwIR.setLocal([1], PlwIR.createRef(IRT_Point)),
		PlwIR.storeI64(0, 0, PlwIR.i32(0), PlwIR.i64(42000000)),
		PlwIR.storeI64(0, 1, PlwIR.i32(0), PlwIR.i64(51000000)),
		PlwIR.storeI64(1, 0, PlwIR.i32(0), PlwIR.i64(12000000)),
		PlwIR.storeI64(1, 1, PlwIR.i32(0), PlwIR.i64(34000000)),
		PlwIR.setLocal([2], PlwIR.callf(IRF_AddPoints, [PlwIR.local(0), PlwIR.local(1)])),
		PlwIR.callf(IRF_PrintI64, [PlwIR.loadI64(2, 0, PlwIR.i32(0))]),
		PlwIR.callf(IRF_PrintI64, [PlwIR.loadI64(2, 1, PlwIR.i32(0))]),
		PlwIR.decRefCount(2),
		PlwIR.ret([])
	])
));

/*

const IRF_Swap = testIRModule.addFunction(new PlwIRFunction(
	"swap",
	null,
	2,
	[PLW_IR_TYPE_I64, PLW_IR_TYPE_I64],
	[PLW_IR_TYPE_I64, PLW_IR_TYPE_I64],
	new PlwIRBlock([
		new PlwIRSetLocal([0], new PlwIRBinOp(PLW_IR_OP_I64_ADD, new PlwIRLocal(0), new PlwIRLocal(1))),		
		new PlwIRReturn([
			new PlwIRLocal(1),
			new PlwIRLocal(0)
		])
	])
));

const IRF_Facto = testIRModule.addFunction(new PlwIRFunction (
	"facto",
	null,
	1,
	[PLW_IR_TYPE_I64],
	[PLW_IR_TYPE_I64],
	new PlwIRBlock([
		new PlwIRIf(new PlwIRBinOp(PLW_IR_OP_I64_EQ, new PlwIRLocal(0), new PlwIRI64(0)),
			new PlwIRReturn([new PlwIRI64(1)]),
			null
		),
		new PlwIRReturn([
			new PlwIRBinOp(PLW_IR_OP_I64_MUL,
				new PlwIRLocal(0),
				new PlwIRCall(3, [
					new PlwIRBinOp(PLW_IR_OP_I64_SUB,
						new PlwIRLocal(0),
						new PlwIRI64(1)
					)
				])
			)
		])
	])
));

const IRF_FactoIter = testIRModule.addFunction(new PlwIRFunction (
	"factoiter",
	null,
	1,
	[PLW_IR_TYPE_I64],
	[PLW_IR_TYPE_I64, PLW_IR_TYPE_I64],
	new PlwIRBlock([
		new PlwIRSetLocal([1], new PlwIRI64(1)),
		new PlwIRLoop(new PlwIRBlock([
			new PlwIRIf(new PlwIRBinOp(PLW_IR_OP_I64_LT, new PlwIRLocal(0), new PlwIRI64(2)), new PlwIRExitLoop(), null),
			new PlwIRSetLocal([1], new PlwIRBinOp(PLW_IR_OP_I64_MUL, new PlwIRLocal(1), new PlwIRLocal(0))),
			new PlwIRSetLocal([0], new PlwIRBinOp(PLW_IR_OP_I64_SUB, new PlwIRLocal(0), new PlwIRI64(1)))
		])),
		new PlwIRReturn([new PlwIRLocal(1)])
	])
));

testIRModule.addGlobal(PLW_IR_TYPE_I64);
*/
// console.log(JSON.stringify(testIRModule));

const IRF_Main = testIRModule.addFunction(new PlwIRFunction("main", null, 0, [], [],
	PlwIR.block([
		PlwIR.callf(IRF_TestAddPoints, []),
		PlwIR.ret([])
	])
));

let compiler = new PlwIRWasmCompiler(testIRModule);
compiler.compileModule();
let bytes = compiler.moduleBytes();

// console.log(JSON.stringify(compiler, true));

// for (let i = 0; i < bytes.length; i++) {
//	console.log("" + i + ": " + bytes[i]);
// }

class PlwStdlib {
	
	printI32(i) {
		console.log("" + i);
	}
	
	printI64(i) {
		console.log("" + i);
	}
}


WebAssembly.instantiate(PLW_RT_MODULE).then((plwruntime) => {
	plwruntime.instance.exports.MEM_init(8);
	let importObject = {
		"plwruntime": plwruntime.instance.exports,
		"stdlib": new PlwStdlib(),
		"plwnative": {
			"print(text)": 	function(ptr) {
				let mem = new Uint32Array(plwruntime.instance.exports.memory.buffer);
				ptr = ptr / 4;
				let len = mem[ptr];
				let codes = mem.slice(ptr + 1, ptr + 1 + len);
				printTextOut(String.fromCharCode(...codes));
			}
		}
	};
	WebAssembly.instantiate(new Uint8Array(bytes), importObject).then((module) => {
		module.instance.exports.main();
		printMemDump(plwruntime.instance);
	});
});

</script>
</body>
